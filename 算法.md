<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: "none" });
</script>

[TOC]

# 二分法

## 跳石头（最优化问题+贪心）

这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $N$ 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。

为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 $M$ 块岩石（不能移走起点和终点的岩石）。求最短跳跃距离的最大值。

**Solution：**

要使得最短跳跃距离最大（设为 $ans$ )，则有：比 $ans$ 还小的跳跃距离，都能实现，若最短跳跃距离比 $ans$ 还大，那么选取的石头肯定要多于 $M$ 块，我们可以将其抽象成下述函数：
$$
f(x)=
\begin{cases}
\,true &,x \in区间1 \\
false &,x \in 区间2 \\
\end{cases}
$$
我们要求的是区间1的有边界，采用二分处理

还有一个困难：

如何取掉石头才能使结果最优，采用贪心法：

比如以下三个点

$A \rightarrow B\rightarrow C$ ：我们搜索的最短跳跃距离是3，而A与B之间的距离是2，应该删A还是B？

应该删除B：因为A及之前的点距离都满足大于最短跳跃距离，故删除A会造成浪费，且不能干扰到B到C之间的距离，而删除B则便利了BC之间的距离（贪心思想）

```C++
#include<iostream>
using namespace std;
int k,n,m;
int pos[50005];
bool check(int x)
{
    int cnt=0,start=0;
    for(int i=0;i<n;i++)
    {
        if(x>pos[i]-start) {
            cnt++;
        }
        else
            start=pos[i];
    }
    return cnt<=m;
}
int main()
{
    cin>>k>>n>>m;
    for(int i=0;i<n;i++)
    {
        cin>>pos[i];
    }
    int l=0,r=k,mid;
    while(l<r)
    {
        mid=(r-l)/2+l;
        if(check(mid)) l=mid+1;
        else r=mid-1;
    }
    if(!check(l)) l--;
    cout<<l<<endl;
    return 0;
}
```

## 刺杀大使（最大最小值+BFS）

某组织正在策划一起对某大使的刺杀行动。他们来到了使馆，准备完成此次刺杀，要进入使馆首先必须通过使馆前的防御迷阵。

迷阵由 $m \times n$ 个相同的小房间组成，每个房间与相邻四个房间之间有门可通行。在第 $n$ 行的 $m$ 个房间里有 $m$ 个机关，这些机关必须全部打开才可以进入大使馆。而第1行的 $m$ 个房间有 $m$ 扇向外打开的门，是迷阵的入口。除了第 $1$ 行和第 $n$ 行的房间外，每个房间都被使馆的安保人员安装了激光杀伤装置，将会对进入房间的人造成一定的伤害。第 $i$ 行第 $j$ 列 造成的伤害值为 $p_{ij}$（第 1 行和第 n 行的 p 值全部为 0）。

现在某组织打算以最小伤害代价进入迷阵，打开全部机关，显然，他们可以选择任意多的人从任意的门进入，但必须到达第 $n$ 行的每个房间。一个士兵受到的伤害值为他到达某个机关的路径上所有房间的伤害值中的最大值，整个部队受到的伤害值为所有士兵的伤害值中的最大值。现在，这个恐怖组织掌握了迷阵的情况，他们需要提前知道怎么安排士兵的行进路线可以使得整个部队的伤害值最小。

**输入格式**

第一行有两个整数 $n,m$，表示迷阵的大小。

接下来 $n$ 行，每行 $m$ 个数，第 $i$ 行第 $j$ 列的数表示 $p_{ij}$。

***Solution：***

要求所有伤害值的最大值的最小值。明显符合二分查找

```C++
#include<iostream>
using namespace std;
#include<queue>
int get()
{
    int x = 0, f = 1; char c = getchar();
    while(!isdigit(c)) { if(c == '-') f = -1; c = getchar(); }
    while(isdigit(c)) { x = x * 10 + c - '0'; c = getchar(); }
    return x * f;
}

const int MaxN = 1005;
const int inf = 0x3f3f3f3f;
const int dx[5] = {0, 1, 0, -1, 0};
const int dy[5] = {0, 0, 1, 0, -1};
int p[MaxN][MaxN], vis[MaxN][MaxN];
int n, m;
int l = inf, r = -inf, mid, ans, f;

bool bfs(int x, int y, int maxn)
{
    queue<pair<int, int> > q;
    q.push(make_pair(x, y));
    vis[x][y] = 1;
    while(q.size())
    {
        int xx = q.front().first;
        int yy = q.front().second;
        q.pop();
        for(int i = 1; i <= 4; i++) {
            int nx = xx + dx[i];
            int ny = yy + dy[i];
            if(nx < 1 || nx > n || yy < 1 || yy > m || vis[nx][ny] || p[nx][ny] > maxn)
                continue;
            vis[nx][ny] = 1;
            if(nx == n) return 1;
            else q.push(make_pair(nx, ny));
        }
    }
    return 0;
}

int main()
{
    n = get(), m = get();
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++) {
            p[i][j] = get();
            r = max(r, p[i][j]);
            l = min(l, p[i][j]);
        }
    }
    while(l <= r) {
        mid = (l + r) >> 1;
        f = 0;
        memset(vis, 0, sizeof(vis));
        if(bfs(1, 1, mid)) r = mid - 1, ans = mid;
        else l = mid + 1;
    }
    printf("%d", ans);
    return 0;
}
```

## 质检员（前缀和）

`小T` 是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有 $n$ 个矿石，从 1 到 $n$ 逐一编号，每个矿石都有自己的重量 $w_i$ 以及价值 $v_i$ 。检验矿产的流程是：

1 、给定 $m$ 个区间 $[l_i,r_i]$；

2 、选出一个参数 $W$；

3 、对于一个区间，计算矿石在这个区间上的检验值 $y_i$：
$$
y_i=\sum_{j=l_i}^{r_i}[w_j\geqslant W]\sum_{j=l_i}^{r_i}[w_j\geqslant W]v_j
$$
其中 $j$ 为矿石编号。

这批矿产的检验结果 $y$ 为各个区间的检验值之和。

若这批矿产的检验结果与所给标准值 $s$ 相差太多，就需要再去检验另一批矿产。`小T` 不想费时间去检验另一批矿产，所以他想通过调整参数 $W$ 的值，让检验结果尽可能的靠近标准值 $s$，即使得 $|s-y|$ 最小。请你帮忙求出这个最小值。

```C++
#include<bits/stdc++.h>
using namespace std;
const int maxn=200010;
int w[maxn],v[maxn],l[maxn],r[maxn];
long long pre_n[maxn],pre_v[maxn];
long long Y,s,sum;
int n,m,mx=-1,mn=2147483647;
bool check(int W)
{	
	Y=0,sum=0;
	memset(pre_n,0,sizeof(pre_n));
	memset(pre_v,0,sizeof(pre_v));
	for(int i=1;i<=n;i++)
	{
		if(w[i]>=W) pre_n[i]=pre_n[i-1]+1,pre_v[i]=pre_v[i-1]+v[i];
		else pre_n[i]=pre_n[i-1],pre_v[i]=pre_v[i-1];
	}
	for(int i=1;i<=m;i++)
		Y+=(pre_n[r[i]]-pre_n[l[i]-1])*(pre_v[r[i]]-pre_v[l[i]-1]);
		

	sum=llabs(Y-s);
	if(Y>s) return true;
	else return false;
	
}
int main(){
	scanf("%d %d %lld",&n,&m,&s); 
	for(int i=1;i<=n;i++)
	{
		scanf(" %d %d",&w[i],&v[i]);
		mx=max(mx,w[i]);
		mn=min(mn,w[i]);	
	}
	for(int i=1;i<=m;i++)
		scanf(" %d %d",&l[i],&r[i]);
	int left=mn-1,right=mx+2,mid;  //细节
	long long ans=0x3f3f3f3f3f3f3f3f;
	while(left<=right)
	{
		mid=(left+right)>>1;
		if(check(mid)) 	left=mid+1;
		else right=mid-1;
		if(sum<ans) ans=sum;
	}
	printf("%lld",ans);
	return 0;
} 
```

# 分治

## 地毯填补（P1228）

```C++
#include<iostream>
using namespace std;
#define ll long long
#define __1 solve(a+l/2-1,b+l/2-1,a,b,l/2)
#define __2 solve(a+l/2-1,b+l/2,a,b+l/2,l/2)
#define __3 solve(a+l/2,b+l/2-1,a+l/2,b,l/2)
#define __4 solve(a+l/2,b+l/2,a+l/2,b+l/2,l/2)
int k,x,y;
ll f(int k)
{
    ll ret=1;
    for(int i=1;i<=k;i++)
        ret*=2;
    return ret;
}
void solve(ll x,ll y,ll a,ll b,ll l) // x,y不能填 a,b是当前左上角
{
    if(l==1) return;
    if(x-a<l/2 && y-b<l/2) // upleft
    {
        printf("%lld %lld 1\n", a+l/2,b+l/2);
        solve(x,y,a,b,l/2); __2; __3; __4;
    }
    else if(x-a<l/2 && y-b>=l/2) // upright
    {
        printf("%lld %lld 2\n", a+l/2,b+l/2-1);
        __1; solve(x,y,a,b+l/2,l/2); __3; __4;
    }
    else if(x-a>=l/2 && y-b<l/2) // downleft
    {
        printf("%lld %lld 3\n", a+l/2-1,b+l/2);
        __1; __2; solve(x,y,a+l/2,b,l/2); __4;
    }
    else // downright
    {
        printf("%lld %lld 4\n", a+l/2-1,b+l/2-1);
        __1; __2; __3; solve(x,y,a+l/2,b+l/2,l/2);
    }
}
int main()
{
    cin>>k>>x>>y;
    ll tot=f(k);
    solve(x,y,1,1,tot);
    return 0;
}

```



# 贪心算法

## 跳跳！

你是一只小跳蛙，你特别擅长在各种地方跳来跳去。

这一天，你和朋友小 F 一起出去玩耍的时候，遇到了一堆高矮不同的石头，其中第 $i$ 块的石头高度为 $h_i$，地面的高度是 $h_0=0$ 。你估计着，从第 $i$ 块石头跳到第 $j$ 块石头上耗费的体力值为 $(h_i−h_j)^2$，从地面跳到第 $i$ 块石头耗费的体力值是  $h_i^2$

为了给小 F 展现你超级跳的本领，你决定跳到每个石头上各一次，并最终停在任意一块石头上，并且小跳蛙想耗费**尽可能多**的体力值。

当然，你只是一只小跳蛙，你只会跳，不知道怎么跳才能让本领更充分地展现。

不过你有救啦！小 F 给你递来了一个写着 AK 的电脑，你可以使用计算机程序帮你解决这个问题，万能的计算机会告诉你怎么跳。

那就请你——会写代码的小跳蛙——写下这个程序，为你 $NOIP\, AK$ 踏出坚实的一步吧！

```C++
#include<iostream>
using namespace std;
long long n,A[301],ans;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)
    cin>>A[i];
    sort(A+1,A+n+1);//STL大法排序
    int q=0,p=n;//p,q分别记录接下来要跳的石头是那块
    while(q<p){
        ans+=pow((A[p]-A[q]),2);//计算跳一次后增加消耗的体力值
        q++;
        ans+=pow((A[q]-A[p]),2);//同上
        p--;
    }
    cout<<ans;//输出
    return 0;
}
```

# 递归

## 汉诺塔

```C++
#include<iostream>
using namespace std;
int step=1;
void move(int x,char a,char b,char c)
{
    if(x==1)
    {
        cout<<step<<" :move 1 from "<<a<<" to "<<c<<endl;
        step++;
        return;
    }
    move(x-1,a,c,b);
    cout<<step<<": move "<<x<<" from "<<a<<" to "<<c<<endl;
    step++;
    move(x-1,b,a,c);
}
int main()
{
    int n;
    cin>>n;
    move(n,'A','B','C');
    return 0;
}
```

## 外星密码 | [P1928](https://www.luogu.com.cn/problem/P1928)

```C++
#include<bits/stdc++.h>
using namespace std;
string read()
{
	int n;
	string s="",s1;
	char c;
	while (cin>>c)
	{
		if (c=='[')
		{
			cin>>n;
			s1=read();
			while (n--) s+=s1;
		}
		else 
		{
			if (c==']') return s;
		  else s+=c;
		}
	}
}
int main()
{
	cout<<read(); 
	return 0;
}
```

## (逆）波兰表达式

每次遇到操作数，压入栈，遇到运算符，pop()两个，最后栈顶就是答案

或递归：

```C++
#include<iostream>
using namespace std;
double exp()
{
    char n[100];
    cin >> n;//依次输入即可，中间加空格
    switch (n[0])
    {
    case'+': return exp() + exp();
    case'-': return exp() - exp();
    case'*': return exp() * exp();
    case'/': return exp() / exp();
    default: return atof(n);//char转换为浮点数
        break;
    }
}
int main()
{
    cout<<exp()<<endl;
    /*例如输入+ 5 3，第一个为+，所以进入exp(),输入的数为5，由于不是‘+-*/’，所以返回int型的5，前面+号右边的输入为3，道理如上，所以返回int 3，一起返回，到5+3=8；*/
    return 0;
}
```

# DP

## 线性DP

### 背包问题

#### 01背包问题

有 *N* 种物品和一个容量是 *V* 的背包，每种物品都有一件可用。第 *i* 种物品的体积是 *$v_i$*，价值是 *$w_i$*。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。

**Solution:** 用$f[i][j]$表示背包容量为j，且取前i件物品时获得的最大利润，建立状态转移方程：
$$
f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i])
$$
其中第一部分表示第i个物品不取(则背包容量仍为j),第二部分表示选取第i个物品，则考察除去第i个物品时，剩余价值是$f[i-1][j-v[i]]$,故总价值是$f[i-1][j-v[i]]+w[i]$，故最大利润为两部分的最大值。

代码实现：

```C++
#include<iostream>
using namespace std;
const int N=1005;
int v[N];
int w[N];
int f[N][N];
int main()
{
  int n,m;
  cin>>n>>m;
  for(int i=1;i<=n;i++)
  {
    cin>>v[i]>>w[i];
  }
  for(int i=1;i<=n;i++)
  {
    for(int j=0;j<=m;j++)
    {
      if(j<v[i])
        f[i][j]=f[i-1][j];
      else
        f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i]);
    }
  }
  cout<<f[n][m]<<endl;
  return 0;
}
```

**代码优化：**

再考察上述状态转移方程，发现与i有关的下标左边全为i,右边全为i-1，符合自然序，故考虑只使用一个下标j来表示f，即：
$$
f[j]=max(f[j],f[j-v[i]]+w[i])
$$
我们再写出对应代码：

```C++
for(int i=1;i<=n;i++)
{
  for(int j=0;j<=m;j++)
  {
    if(j<v[i])
      f[j]=f[j];
    else
      f[j]=max(f[j],f[j-v[i]]+w[i]);
  }
}
```

此时会产生问题：由于$j-v[i]<j$，所以我们调用状态转移方程时的$f[j-v[i]]$其实是$f[i][j-v[i]]$！所以此时对于j我们应该采取反向遍历，即：

```C++
for(int i=;i<=n;i++)
{
  for(int j=m;j>=0;j--)
  {
    if(j<v[i])
      f[j]=f[j];
    else
      f[j]=max(f[j],f[j-v[i]]+w[i]);
  }
}
```

进一步优化：

```C++
for(int i=1;i<=n;i++)
{
  for(int j=m;j>=v[i];j--)
  {
      f[j]=max(f[j],f[j-v[i]]+w[i]);
  }
}
```

注意到在处理数据时是一个一个物品的体积和价值枚举，故我们可以一边输入一边判断，最终代码如下：

```C++
#include<iostream>
using namespace std;
int main()
{
  int n,m;
  cin>>n>>m;
  int v,w;
  int f[1005];
  for(int i=1;i<=n;i++)
  {
    cin>>v>>w;
    for(int j=m;j>=v;j--)
    {
      f[j]=max(f[j],f[j-v]+w);
    }
  }
  cout<<f[m]<<endl;
  return 0;
}
```

##### 摆花|[P1077](https://www.luogu.com.cn/problem/P1077)

01背包+前缀和优化

```C++
#include<iostream>
using namespace std;
const int maxn = 105, mod = 1000007;
int n, m, f[maxn], sum[maxn], a[maxn];
int main(){
    cin>>n>>m;
    for(int i=1; i<=n; i++) cin>>a[i];
    f[0] = 1;
    for(int i=0; i<=m; i++) sum[i] = 1;
    for(int i=1; i<=n; i++){
    	for(int j=m; j>=1; j--) f[j] = (f[j] + sum[j-1] - sum[j - min(a[i], j) - 1] + mod)%mod;
        for(int j=1; j<=m; j++) sum[j] = (sum[j-1] + f[j])%mod;
    }
    cout<<f[m]<<endl;
    return 0;
}
```

##### 垃圾陷阱 | [P1156](https://www.luogu.com.cn/problem/P1156)

状态转移比较神奇: $f[i]$ 代表高度是 $i$ 的最大体力

```C++
# include<iostream>
# include<cstring>
# include<algorithm>
using namespace std;
struct r{
    int t,h,l;
}c[101];
int d,g;
int ti[101];
int f[101];
bool cmp(r a,r b)
{
    return a.t<b.t;
}
int main()
{
    cin>>d>>g;
    for(int i=1;i<=g;i++)
      cin>>c[i].t>>c[i].l>>c[i].h;
    sort(c+1,c+1+g,cmp);
    f[0]=10;
    for(int i=1;i<=g;i++)
      for(int j=d;j>=0;j--)
        if(f[j]>=c[i].t)
        {
            if(j+c[i].h>=d)
            {
                cout<<c[i].t;
                return 0;
            }
            f[j+c[i].h]=max(f[j+c[i].h],f[j]);
            f[j]+=c[i].l;
        }
    cout<<f[0]<<endl;
    return 0;
}
```



#### 完全背包问题

有 *N* 种物品和一个容量是 *V* 的背包，每种物品都有无限件可用。第 *i* 种物品的体积是 *$v_i$*，价值是 *$w_i$*。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。

**Solution:** 用$f[i][j]$表示背包剩余容量为 $j$，且取前 $i$ 件物品时获得的最大利润，建立状态转移方程：
$$
f[i][j]=\max（f[i-1][j],f[i-1][j-kv[i]]+kw[i])
$$
$k$从0到满足$j-kv[i]\geqslant0$的范围内遍历，代码如下：

```C++
#include<iostream>
using namespace std;
const int N=1005;
int v[N];
int w[N];
int f[N][N];
int main()
{
  int n,m;
  cin>>n>>m;
  for(int i=1;i<=n;i++)
  {
    cin>>v[i]>>w[i];
  }
  for(int i=1;i<=n;i++)
  {
    for(int j=0;j<=m;j++)
    {
      for(int k=0;k*v[i]<=j;k++)
      {
        f[i][j]=max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]);
      }
    }
  }
  cout<<f[n][m]<<endl;
  return 0;
}
```

但**Time Limit Exceeded!** 考虑优化方式，因k过于复杂，考虑去掉k，再考察状态转移方程：
$$
\quad \quad \quad \quad \quad \quad \quad \quad f[i][j]=\max(f[i-1][j-0]+0,f[i-1][j-v]+w,f[i-1][j-2v]+2w)\\
f[i][j-v]=\max(\quad \quad \quad f[i-1][j-v],f[i-1][j-2v]+w,...)
$$
逐项比较可知：
$$
f[i][j]=\max(f[i-1][j],f[i][j-v]+w)
$$
可发现和01背包问题基本一致，代码如下：

```C++
for(int i=1;i<=n;i++)
{
  for(int j=v[i];j<=m;j++)
  {
    f[i][j]=max(f[i-1][j],f[i][j-v[i]]+w[i]);
  }
}
```

同之前讨论可以对空间复杂度进行优化：
$$
f[j]=\max(f[j],f[j-v]+w)
$$

```C++
for(int i=1;i<=n;i++)
{
  for(int j=v[i];j<=m;j++)
  {
    f[j]=max(f[j],f[j-v[i]]+w);
  }
}
```

**注意此时j从0开始遍历**，因为$j-v<j$，所用的$f[j-v]$是$f[i][j-v]$

最终代码如下：

```C++
#include<iostream>
using namespace std;
const int N=1005;
int f[N];
int main()
{
  int n,m;
  cin>>n>>m;
  for(int i=1;i<=n;i++)
  {
    int v,w;
    cin>>v>>w;
    for(int j=v;j<=m;j++)
    	f[j]=max(f[j],f[j-v]+w);
  }
  cout<<f[m]<<endl;
  return 0;
}
```

#### 多重背包问题1

有N种物品和一个容量是V的背包。第i种物品最多有$s_i$件，每件体积是$v_i$，价值是$w_i$。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。

**Solution:** 用$f[i][j]$表示背包剩余容量为j，且取前i件物品时获得的最大利润，建立状态转移方程：
$$
f[i][j]=max(f[i][j],f[i-1][j-k*v[i]]+w[i])
$$
$k$从0到$s_i$遍历，且需满足$k\cdot v[i]\leqslant j$，代码如下：

```C++
#include<iostream>
using namespace std;
const int N=105;
int v[105],s[105],w[105],f[105][105];
int main()
{
  int n,m;
  cin>>n>>m;
  for(int i=1;i<=n;i++)
  {
    cin>>v[i]>>w[i]>>s[i];
  }
  for(int i=1;i<=n;i++)
  {
    for(int j=0;j<=m;j++)
    {
      for(int k=0;k<=s[i];k++)
      {
        if(j>=k*v[i])
          f[i][j]=max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]);
      }
    }
  }
  cout<<f[n][m]<<endl;
  return 0;
}
```



优化空间复杂度：把多重背包转换成01背包：

```C++
#include<iostream>
using namespace std;
const int N=10005;
int a[N],b[N],f[N];
int main()
{
  int cnt=0,n,m,w,v,s;
  cin>>n>>m;
  while(n--)
  {
    cin>>v>>w>>s;
    //拆分
    while(s--)
    {
      a[++cnt]=v;
      b[cnt]=w;
    }
  }
  //以下是01背包问题
  for(int i=1;i<=cnt;i++)
  {
    for(int j=m;j>=a[i];j--)
    {
      f[j]=max(f[j],f[j-a[i]]+b[i]);
    }
  }
  cout<<f[m]<<endl;
  return 0;
}
```

#### 多重背包问题2

题目同1，数据变大，考察多重背包二进制优化方法

**Solution:** 二进制拆分成01背包问题：

以11为例，11可以拆分成：
$$
11=1011(B)=0111(B)+(11-0111(B))=0111(B)+0100(B)
$$
故11可以被拆分成1，2，4，4，从而转化成01背包，减少了枚举次数

**P.S** 之所以这么拆分，是因为0111(B)是小于11的最大的尾部全为1的二进制，尾部全为1的数又可以 分解为 0000....1 , 0000....10 , 0000....100 等等。因此可给出拆分代码：

```c++
//设有s个商品
for(int k=1;k<=s;k*=2)
{
  s-=k;
  good.push_back({v*k,w*k});//对应1011（B）
}
if(s>0)
  good.push_back({v*s,w*s});//对应11-1011（B）
```

代码如下：

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int f[2010];
struct good
{
  int v;
  int w;
};
int main()
{
  vector<good> g;
  int n,m;
  cin>>n>>m;
  for(int i=0;i<n;i++)
  {
    int v,w,s;
    cin>>v>>w>>s;
    for(int k=1;k<=s;k*=2)
    {
      s-=k;
      g.push_back({v*k,w*k});
    }
    if(s>0)
      g.push_back({v*s,w*s});
  } //nlogs
  for(auto t:g)
  {
    for(int i=m;i>=t.v;i--)
    {
      f[i]=max(f[i],f[i-t.v]+t.w);
    }
  }
  cout<<f[m]<<endl;
  return 0;
}
```

#### 多重背包问题3

##### 单调队列优化

同上题，数据更大，考察单调队列优化：

**Solution:** 

------

**基础知识——单调队列+滑动窗口：**

<!-- ![u=3655810071,3985666514&fm=173&app=25&f=JPEG](/Users/muzhancun/Desktop/C++ learning/笔记/u=3655810071,3985666514&fm=173&app=25&f=JPEG.jpg) -->

e.g 这是一个长度为3的滑动窗口，以此为例。我们定义一个单调队列：队头最大，其他单调递减。当加入新元素b时从队尾遍历，直至找到第一个比其大的元素a，在a之后插入b，并让队列中比b小的元素出队，当队头不在滑动窗口范围内时自动出队：

```
step 1:滑动窗口起始端pos=1;deque={5}
step 2:滑动窗口起始端pos=2;5出队;deque={3}
step 3:滑动窗口起始端pos=3;3出队;deque={2}
step 4:滑动窗口起始端pos=4;2出队;7入队;deque={7}
step 5:滑动窗口起始端pos=5;8入队并且7出队;deque={8};
以下都是8最大
```

数组实现：

```C++
#include<iostream>
using namespace std;
struct Node
{
  int pos,val;
}q[1005]；
int main()
{
  int n,m;//n是序列长度，m是窗口长度
  cin>>n>>m;
  int front=1,back=0;//初始化队尾队头，队尾小于队头说明队为空
  int a[1005];
  for(int i=0;i<n;i++)
  {
    cin>>a[i];
  }
  for(int i=0;i<n;i++)
  {
    if(front>back)
      cout<<" "<<endl;//队列为空
    else
    {
      if(q[front].pos+m<i)
        front++;//当队头不在滑动窗口范围内时自动出队
      cout<<q[front].val<<endl;//打印最大值
    }
    while(front<=back&&q[back].val<=a[i])
      back--;
    q[++back].x=a[i];
    q[back].pos=i;
  }
}
```

------

**问题分析**：我们先来回顾传统的状态转移方程：
$$
f[i][j]=max(f[i][j],f[i-1][j-kv[i]]+w[i])
$$
事实上不需要二维数组：
$$
f[j]=max(f[j],f[j-kv]+w)
$$
上述的$j$从0遍历到$m$，故$m$可以表示成$kv+j$，其中$0 \leqslant j< v$（注意这里$j$的含义不同），也就是说我们可以对j进行遍历，来找到$\max \{f[j],f[j+v],…,f[j+kv]\}$，所以，我们可以把 $f$ 数组分成 $j$ 个类，每一类中的值，都是在同类之间转换得到的，也就是说，$f[kv+j]$ 只依赖于 ${ f[j], f[v+j], f[2v+j], f[3v+j], ... , f[kv+j] }$，因为我们需要的是${ f[j], f[v+j], f[2v+j], f[3v+j], ... , f[kv+j] }$ 中的最大值，可以通过维护一个单调队列来得到结果。这样的话，问题就变成了 $j$ 个单调队列的问题。

$$
\begin{aligned}
f[j]  &= f[j]\\
f[j+v] &= max(f[j]+w,f[j+v])\\
f[j+2v] &= max(f[j]+2w,f[j+v]+w,f[j+2v])\\
f[j+3v] &= max(f[j]+3w,f[j+v]+2w,f[j+2v]+w,f[j+3v])\\
…
\end{aligned}
$$
但是队列前面的数每次会加一个$w$，我们不妨采用如下变换:
$$
\begin{aligned}
f[j]  &= f[j]\\
f[j+v] &= max(f[j],f[j+v]-w)+w\\
f[j+2v] &= max(f[j],f[j+v]-w,f[j+2v]-2w)+2w\\
f[j+3v] &= max(f[j],f[j+v]-w,f[j+2v]-2w,f[j+3v]-3w)+3w...
\end{aligned}
$$
这样每次入队的值是$f[j+k*v]-k*w$,

```C++
#include <iostream>
#include <cstring>//memcpy
using namespace std;
const int N = 20010;
int dp[N], pre[N], q[N];
int n, m;
int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; ++i) {
        memcpy(pre, dp, sizeof(dp));
        int v, w, s;
        cin >> v >> w >> s;
        for (int j = 0; j < v; ++j) {
            int head = 0, tail = -1;//队尾小于队头说明单调队列为空，q[]表示体积，单位为v
            for (int k = j; k <= m; k += v) {
                if (head <= tail && k - s*v > q[head])
                    ++head;//队头越界，出队
                while (head <= tail && pre[q[tail]] - (q[tail] - j)/v * w <= pre[k] - (k - j)/v * w)
                    --tail;//插入pre[k]
                if (head <= tail)
                    dp[k] = max(dp[k], pre[q[head]] + (k - q[head])/v * w);
                q[++tail] = k;
            }
        }
    }
    cout << dp[m] << endl;
    return 0;
}
```

##### 应用——「SWTR-03」Golden Sword | [P5858](https://www.luogu.com.cn/problem/P5858)

```C++
#include<bits/stdc++.h>
using namespace std;
long long n,m,s,a[5505],dp[5505][5505],q[5505],pos[5505];
int main(){
  scanf("%lld %lld %lld",&n,&m,&s);
  for(long long i=1;i<=n;++i) scanf("%lld",&a[i]);
  for(long long i=0;i<=n;++i)	
    for(long long j=0;j<=m;++j)	
      dp[i][j]=-1000000000000000;
  dp[0][0]=0;
  for(long long i=1;i<=n;++i)
  {
    int l=1,r=1;
    q[l]=dp[i-1][m];
    pos[l]=m;
    for(long long j=m;j;--j)
    {
      while(pos[l]>j+s-1 && l<=r)	++l;
      while(q[r]<dp[i-1][j-1] && l<=r)	--r;
      pos[++r]=j-1;
      q[r]=dp[i-1][j-1];
      dp[i][j]=q[l]+j*a[i];
    }
  }
  long long ans=-1000000000000000;
  for(long long i=0;i<=m;++i) ans=max(ans,dp[n][i]);
  printf("%lld",ans);
  return 0;
}
```
##### 单调队列补充
###### 切蛋糕|[P1714](https://www.luogu.com.cn/problem/P1714)

考虑以 $i$ 结尾的子段，$p[i]$ 维护最大子段和
$$
\begin{aligned}
p[i] &=\max(sum[i]-sum[j]),j\in [j-m,i-1] \\
     &=sum[i]-\min sum[j]
\end{aligned}
$$
因此是能用单调队列进行维护的

```C++
#include<iostream>
#include<deque>
using namespace std;
const int maxn=1e9+10;
const int mod=1e9+7;
int ans=-1e9,n,m,a,sum[maxn];
deque<int> q;
int main(){
  cin>>n>>m;
  for(int i{1};i<=n;i++){
    cin>>a;
    sum[i]=sum[i-1]+a;
  }
  q.push_back(0);
  for(int i={1};i<=n;i++){
    while(q.front()+m<i){
      q.pop_front();
    }
    ans=max(ans,sum[i]-sum[q.front()]);
    while(!q.empty()&&sum[q.back()]>=sum[i]){
      q.pop_back();
    }
    q.push_back(i);
  }
  cout<<ans<<endl;
  return 0;
}
```
#### 混合背包问题

有$N$种物品和一个容量是$V$的背包。物品一共有三类：

- 第一类物品只能用1次（01背包）；
- 第二类物品可以用无限次（完全背包）；
- 第三类物品最多只能用 $s_i$ 次（多重背包）；

每种体积是$v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。

**Solution:**把混合背包问题转化成01背包问题：完全背包可看成物品数量为$\frac{V}{s_i}$的多重背包，再用多重背包的思路转换成二进制处理即可

```C++
#include<iostream>
using namespace std;
const int N=100010;
int n,m,v[N],w[N],f[N];
int main()
{
  cin>>n>>m;
  int cnt=1;
  for(int i=1;i<=n;i++)
  {
    int a,b,s;
    cin>>a>>b>>s;
    int k=1;
    if(s<0) s=1;
    else if(s==0) s=m/a;
    while(k<=s)
    {
      v[cnt]=a*k;
      w[cnt]=b*k;
      s-=k;
      k*=2;
      cnt++;
    }
    if(s>0)
    {
      v[cnt]=a*s;
      w[cnt]=b*s;
      cnt++;
    }
  }
  for(int i=1;i<=cnt;i++)
  {
    for(int j=m;j>=v[i];j--)
      f[j]=max(f[j],f[j-v[i]]+w[i]);
  }
  cout<<f[m]<<endl;
  return 0;
}
```

#### 二维费用的背包问题

有$N$件物品和一个容量是$V$的背包，背包能承受的最大重量是$V$。每件物品只能用一次。体积是$v_i$，重量是 $m_i$，价值是$w_i$。求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。输出最大价值。

***Solution:***同01背包：

```C++
#include<iostream>
using namespace std;
const int MAX=1005;
int N,V,M,f[MAX][MAX];
int main()
{
    cin>>N>>V>>M;
    for(int i=1;i<=N;i++)
    {
        int v,m,w;
        cin>>v>>m>>w;
        for(int j=V;j>=v;j--)
        {
            for(int x=M;x>=m;x--)
            f[j][x]=max(f[j][x],f[j-v][x-m]+w);
        }
    }
    cout<<f[V][M]<<endl;
    return 0;
}
```

#### 分组背包问题

有$N$组物品和一个容量是$V$的背包。每组物品有若干个，同一组内的物品最多只能选一个。每件物品的体积是$v_{ij}$价值是$w_{ij}$，其中$i$是组号，$j$组内编号。求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值。

**Solution:** 同01背包:

```C++
#include<iostream>
using namespace std;
const int MAX=110;
int N,V,v[MAX][MAX],w[MAX][MAX],s[MAX],f[MAX];
int main()
{
  cin>>N>>V;
  for(int i=0;i<N;i++)
  {
    cin>>s[i];
    for(int j=0;j<s[i];j++)
      cin>>v[i][j]>>w[i][j];
  }
  for(int i=0;i<N;i++)
  {
    for(int j=V;j>=0;j--)
    {
      for(int k=0;k<s[i];k++)
        if(f[j]>=v[i][k]) f[j]=max(f[j],f[j-v[i][k]]+w[i][k]);
    }
  }
  cout<<f[V]<<endl;
  return 0;
}
```

#### 有依赖的背包问题

有$N$个物品和一个容量是$V$的背包。物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。如下图所示：

![1_bb51ecbcd2-QQ图片20181018170337](/Users/muzhancun/Desktop/C++ learning/笔记/1_bb51ecbcd2-QQ图片20181018170337.png)

如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。每件物品的编号是$i$，体积是 $v_i$，价值是$w_i$，依赖的父节点编号是$p_i$。物品的下标范围是$1…N$。求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。输出最大价值。

***Solution:***

```C++
#include<iostream>
#include<vector>
using namespace std;
int f[110][110];//f[x][v]表达选择以x为子树的物品，在容量不超过v时所获得的最大价值
vector<int> g[110];
int v[110],w[110];
int n,m,root;

int dfs(int x)
{
    for(int i=v[x];i<=m;i++) f[x][i]=w[x];//点x必须选，所以初始化f[x][v[x] ~ m]= w[x]
    for(int i=0;i<g[x].size();i++)
    {
        int y=g[x][i];
        dfs(y);
        for(int j=m;j>=v[x];j--)//j的范围为v[x]~m, 小于v[x]无法选择以x为子树的物品
        {
            for(int k=0;k<=j-v[x];k++)//分给子树y的空间不能大于j-v[x],不然都无法选根物品x
            {
                f[x][j]=max(f[x][j],f[x][j-k]+f[y][k]);
            }
        }
    }
}

int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        int fa;
        cin>>v[i]>>w[i]>>fa;
        if(fa==-1)
            root=i;
        else
            g[fa].push_back(i);
    }
    dfs(root);
    cout<<f[root][m];
    return 0;
}
```

##### [CTSC1997]选课 | [P2014](https://www.luogu.com.cn/problem/P2014)

```C++
#include<iostream>
#include<cmath>
#include<iomanip>
#include<string>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
#include<bitset>
#include<map>
#include<stack>
#include<list>
#include<deque>
using namespace std;
int n,m,fa,s[305];
vector< vector<int> > v;
int dp[305][305];
void dfs(int x)
{
    for(int i=1;i<=m;i++) dp[x][i]=s[x];
    for(int i=0;i<v[x].size();i++)
    {
        int y=v[x][i];
        dfs(y);
        for(int j=m;j>=((x==0)?0:1);j--)
        {
            for(int k=0;k<=j-((x==0)?0:1);k++)
            {
                dp[x][j]=max(dp[x][j],dp[x][j-k]+dp[y][k]);
            }
        }
    }
}
inline int read()
{
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=((s<<3)+(s<<1)+(ch^48)),ch=getchar();
    return s*w;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    memset(s,0,sizeof(s));
    cin>>n>>m;
    v.resize(305);
    for(int i=1;i<=n;i++)
    {
        cin>>fa;
        cin>>s[i];
        v[fa].push_back(i);
    }
    dfs(0);
    cout<<dp[0][m]<<endl;
    return 0;
}
```



#### 背包问题求方案数

有N件物品和一个容量是V的背包。每件物品只能使用一次。第i件物品的体积是$v_i$，价值是$w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最优选法的方案数。注意答案可能很大，请输出答案模$10^9+7$的结果。

***Solution:***

本题求01背包的最佳方案数，那么定义两个数组：$f[N],cnt[N]$。$f[i]$用来存储背包容积为i时的最佳方案的总价值，$cnt[i]$为背包容积为i 时总价值为最佳的方案数。

当$f[j]<f[j-v]+w$时，将$cnt[j]$更新为$cnt[j-v]$，$f[j]$更新成$f[j-v]+w$,如果二者相等，则$cnt[j]+=cnt[j-v]$

```C++
#include<iostream>
using namespace std;
const int N=1010;
const int mod=1e9+7;
int f[N],cnt[N];
int main()
{
  int n,V;
  cin>>n>>V;
  for(int i=0;i<=V;i++) cnt[i]=1;
  for(int i=1;i<=n;i++)
  {
    int v,w;
    cin>>v>>w;
    for(int j=V;j>=v;j--)
    {
      if(f[j]<f[j-v]+w)
      {
        f[j]=f[j-v]+w;
        cnt[j]=cnt[j-v];
      }
      else if(f[j]==f[j-v]+w)
      {
        cnt[j]=(cnt[j]+cnt[j-v])%mod;
      }
    }
  }
  cout<<cnt[V]<<endl;
}
```

#### 背包问题求具体方案            

有N件物品和一个容量是V的背包。每件物品只能使用一次。第i件物品的体积是$v_i$，价值是$w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出**字典序最小的方案**。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是$1…N$。

***Solution:***

由于题目要求求字典序最小的方案，因此从1到n中，每个物品有3种情况

    (1)只能选，则必须选
    
    (2)不能选，则必不选
    
    (3)可选可不选，则必须选
    在前面物品能选的情况下优先选择前面的物品

状态转移方程：
$$
f(i,j)=max(f(i+1,j),f(i+1,j−v[i])+w[i])
$$
注意这里的j指的是从第i个元素到最后一个元素总容量为j，则最大价值相应变为$f[i][v]$，以第一个物品为例:

如果$f(1,m)=f(2,m−v[1])+w[1]$，说明选取了第1个物品可以得到最优解。

如果$f(1,m)=f(2,m)$，说明不选取第一个物品才能得到最优解。

如果$f(1,m)=f(2,m)=f(2,m−v[1])+w[1]$，说明选不选都可以得到最优解，但是为了考虑字典序最小，我们也需要选取该物品。

```C++
#include<iostream>
using namespace std;
const int N=2010;
int f[N][N];
int v[N],w[N];
int main()
{
  int n,V;
  cin>>n>>V;
  for(int i=1;i<=n;i++)
  {
    cin>>v[i]>>w[i];
  }
  for(int i=n;i>=1;i--)
  {
    for(int j=0;j<=V;j++)
    {
      f[i][j]=f[i+1][j];
      if(j>=v[i])
      f[i][j]=max(f[i][j],f[i+1][j-v[i]]+w[i]);
    }
  }
  int cur_v=V;
  for(int i=1;i<=n;i++)
  {
    if(i==n&&cur_v>=v[i])
    {
      cout<<i<<endl;
    }
    if(cur_v<=0) break;
    if(i!=n&&cur_v-v[i]>=0&&f[i][cur_v]==f[i+1][cur_v-v[i]]+w[i])
    {
      cout<<i<<" ";
      cur_v-=v[i];
    }
  }
}
```

为何要这样遍历？我们不妨给出正常遍历的代码:

```C++
#include<iostream>
using namespace std;
const int N=2010;
int v[N],w[N],f[N][N];
int main()
{
  int n,V;
  cin>>n>>V;
  for(int i=1;i<=n;i++)
  {
    cin>>v[i]>>w[i];
    for(int j=V;j>v[i];j--)
    f[i][j]=max(f[i][j],f[i-1][j-v[i]]+w[i]);
  }
  int cur_v=V;
  for(int i=1;i<=n;i++)
  {
    if(i==n&&cur_v>v=[i])
      cout<<i<<endl;
    if(cur_v<=0) break;
    if(i!=n&&cur_v-v[i]>=0&&f[i][cur_v]==f[i-1][cur_v-v[i]]+w[i])
    {
      cout<<i<<" ";
      cur_v-=v[i];
    }
  }
}
```

注意判断条件是$f[i][cur\_v]==f[i-1][cur_v-v[i]]+w[i]$，比较的是此状态与上个状态而非下个状态，不符合字典序，故我们本题采取逆序遍历。

#### Cow Frisbee Team S | [P2946](https://www.luogu.com.cn/problem/P2946)

老唐最近迷上了飞盘，约翰想和他一起玩，于是打算从他家的 $N$ 头奶牛中选出一支队伍。

每只奶牛的能力为整数，第 $i$ 头奶牛的能力为 $R_i$。飞盘队的队员数量不能少于1、大于 $N$。一支队伍的总能力就是所有队员能力的总和。

约翰比较迷信，他的幸运数字是 $F$ ，所以他要求队伍的总能力必须是 $F$ 的倍数。请帮他算一下，符合这个要求的队伍组合有多少？由于这个数字很大，只要输出答案对 $10^8$ 取模的值。

**Solution:**

状态转移方程：
$$
h[i][j]=h[i][j]+h[i−1][j]+h[i−1][j−r[i]]。
$$
其中 $j$ 代表了总和 $\mod F$

```C++
#include<bits/stdc++.h>
const int p=1e8;//定义常数
const int N=2000+10;
const int F=1000+10;
using namespace std;

int n,f,r[N];
long long h[N][F];

int main()
{
	int i,j;
	cin>>n>>f;
	for(i=1;i<=n;i++)
	{
	  cin>>r[i];
	  r[i]%=f;
	}
	for(i=1;i<=n;i++) h[i][r[i]]=1;
	for(i=1;i<=n;i++)
	  for(j=0;j<f;j++)
	    h[i][j]=((h[i][j]+h[i-1][j])%p+h[i-1][(j-r[i]+f)%f])%p;
	cout<<h[n][0]<<endl;
	return 0;
}
```



### 栈｜[P1044](https://www.luogu.com.cn/problem/P1044)

```C++
#include<iostream>
using namespace std;
#define MAX_N 20
#define ll long long
using namespace std;
int n;
ll f[MAX_N][MAX_N]; //i:入栈数；j:出栈数
int main()
{
  scanf("%d",&n);
  for(int i=0;i<=n;i++)
  {
    f[0][i]=1;
  }
  for(int i=1;i<=n;i++)
  {
    for(int j=i;j<=n;j++)
    {
      if(i==j)f[i][j]=f[i-1][j];
      else f[i][j]=f[i][j-1]+f[i-1][j];
    }
  }
  printf("%lld",f[n][n]);
  return 0;
}
```

### [SCOI2009]粉刷匠 | [P4158](https://www.luogu.com.cn/problem/P4158)
```C++
#include<iostream>
#include<cmath>
#include<iomanip>
#include<string>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
#include<bitset>
#include<map>
#include<stack>
#include<list>
#include<deque>
using namespace std;
int f[51][2550],sum[51][2550];
int g[51][2550][51];
int n,m,t;
char s[150];
/*
f:dp1[i][j]代表前i行用了j次
g:dp2[i][j][k]代表第i行用了j次粉刷了前k个格子
则：
dp1[i][j]=max(dp1[i][j],dp1[i-1][j-k]+dp2[i][k][m])
dp2[i][j][k]=max(dp2[i][j][k],dp2[i][j-1][x]+max(sum[i][k]-sum[i][x],k-x-sum[i][k]+sum[i][x]))
sum记录蓝色格子的前缀和，看蓝色和粉色哪个多，多这一段就涂这个
*/
inline int read()
{
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=((s<<3)+(s<<1)+(ch^48)),ch=getchar();
    return s*w;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin>>n>>m>>t;
    for(int i=1;i<=n;i++)
    {
      cin>>s;
      sum[i][0]=0;
      for(int j=1;j<=m;j++)
      {
        if(s[j-1]=='1') sum[i][j]=sum[i][j-1]+1;
        else sum[i][j]=sum[i][j-1];
      }
    }
    for(int i=1;i<=n;i++)
    {
      for(int j=1;j<=t;j++)
      {
        for(int k=1;k<=m;k++)
        {
          for(int q=j-1;q<k;q++)
          g[i][j][k]=max(g[i][j][k],g[i][j-1][q]+max(sum[i][k]-sum[i][q],k-q-sum[i][k]+sum[i][q]));
        }
      }
    }
    for(int i=1;i<=n;i++)
    {
      for(int j=1;j<=t;j++)
      {
        for(int k=0;k<=min(j,m);k++)
        f[i][j]=max(f[i][j],f[i-1][j-k]+g[i][k][m]); 
      }
    }
    int ans=0;
    for(int i=1;i<=t;i++) ans=max(ans,f[n][i]);
    cout<<ans<<endl;
    return 0;
}
```
### [HAOI2009]逆序对数列 | [P2513](https://www.luogu.com.cn/problem/P2513)

状态：$f[i][j]$ 代表 $i$ 个数的逆序数是 $j$ 的个数，状态转移：
$$
f[i][j]=\sum_{s=0}^{\max(i-1,j)}f[i-1][j-s]
$$
解释：把第 $i$ 个数插到 $i-1$ 个数中最多有 $i-1$ 种情况

前缀优化：

记 $sum[i][j]=f[i][0]+\cdots+f[j]$，转移方程就变成了：
$$
f[i][j]=sum[i-1][j]-(j>i?sum[i-1][j-i]:0)
$$

```C++
#include<iostream>
using namespace std;
const int mod=10000;
int n,k,f[1005][1005],sum[1005];
int main()
{
    cin>>n>>k;
    f[0][0]=1;
    for(int i=0;i<=k;i++) sum[i]=1;
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<=k;j++)
        {
            if(j>=i) f[i][j]=(sum[j]-sum[j-i]+mod)%mod;
            else f[i][j]=sum[j]%mod;
        }
        sum[0]=f[i][0]%mod;
        for(int j=1;j<=k;j++)
        sum[j]=(f[i][j]+sum[j-1])%mod;
    }
    cout<<f[n][k]<<endl;
    return 0;
}
```

### 最长不上升（下降）子序列

#### 模版：导弹拦截|[P1020](https://www.luogu.com.cn/problem/P1020)

```C++
#include<cstdio>
#include<algorithm>

using namespace std;
int n,ans1,ans2,f[100001],a[100001];

int main(){
    while(scanf("%d",&a[++n])!=EOF);
    n--;
  //求最长不上升子序列
  //f[i]代表以第i个元素开始的最长不上升子序列
    for(int i=n;i>=1;i--){ //倒序，因为下一步更新的时候会用到后面的结果
        f[i]=1;
        for(int j=i+1;j<=n;j++){
            if(a[j]<=a[i])
                f[i]=max(f[i],f[j]+1);
        }
        ans1=max(ans1,f[i]);
    }
  //Dilworth定理：偏序集的最少反链划分数等于最长链的长度
  
  //求最长上升子序列
  //f[i]代表以第i个元素结尾的最长上升子序列，要正序
    for(int i=1;i<=n;i++){
        f[i]=1;
        for(int j=1;j<i;j++){
            if(a[j]<a[i])
                f[i]=max(f[i],f[j]+1);
        }
        ans2=max(ans2,f[i]);
    }
    printf("%d\n%d\n",ans1,ans2);
}

```

$O(n\log n)$ 优化：**树状数组**

```C++
#include<iostream>
#include<algorithm>

using namespace std;
int n,maxn,ans1,ans2,f[1000001],a[1000001];

int lowbit(int x){return x&-x;}

void add(int x,int c){ 
  for(int i=x;i<=maxn;i+=lowbit(i)) f[i]=max(f[i],c);//维护最大值 
}

int query(int x){
  int res=0;
  for(int i=x;i>=1;i-=lowbit(i)) res=max(res,f[i]);//求以小于等于x的数为结尾的最长不上升子序列的长度的最大值 
  return res;
}


int main(){
  while(scanf("%d",&a[++n])!=EOF) maxn=max(maxn,a[n]);
  n--;//要-1，不然n就不是正确的n了 
  for(int i=n;i>=1;i--){//从后往前循环 
    int q=query(a[i])+1;//查询以小于等于x的数为开头的最长不上升子序列的长度的最大值
    add(a[i],q);//这个最大值+1就是以当前这个数开头的最长不上升子序列的长度，丢到树状数组里面去 
    ans1=max(ans1,q); 
  }
  printf("%d\n",ans1);
  memset(f,0,sizeof(f));//还是memset一下比较保险 
  for(int i=1;i<=n;i++){//从前往后循环 
    int q=query(a[i]-1)+1;//查询以小于（没有等于！！！）x的数为结尾的最长上升子序列的长度的最大值
    add(a[i],q);//这个最大值+1就是以当前这个数结尾的最长上升子序列的长度，丢到树状数组里面去 
    ans2=max(ans2,q);
	}
	printf("%d\n",ans2);
}
```

优化2: $dp[i]$ 改成**该序列中，上升子序列长度为i的上升子序列的最小末尾数值**，这其实就是一种几近贪心的思想：我们当前的上升子序列长度如果已经确定，那么**如果这种长度的子序列的结尾元素越小，后面的元素就可以更方便地加入到这条我们臆测的、可作为结果的上升子序列中。**

```C++
  int n;
  cin>>n;
  for(int i=1;i<=n;i++)
  {
    cin>>a[i];
    f[i]=0x7fffffff; 
    //初始值要设为INF
    /*原因很简单，每遇到一个新的元素时，就跟已经记录的f数组当前所记录的最长
    上升子序列的末尾元素相比较：如果小于此元素，那么就不断向前找，直到找到
    一个刚好比它大的元素，替换；反之如果大于，那么填到末尾元素的下一个q，INF
    就是为了方便向后替换*/ 
  }
  f[1]=a[1];
  int len=1;//通过记录f数组的有效位数，求得个数 
  /*因为上文中所提到我们有可能要不断向前寻找，
  所以可以采用二分查找的策略，这便是将时间复杂
  度降成nlogn级别的关键因素。*/ 
  for(int i=2;i<=n;i++)
  {
    int l=0,r=len,mid; //len
    if(a[i]>f[len]) f[++len]=a[i]; 					
    //如果刚好大于末尾，暂时向后顺次填充 
    else 
    {
      while(l<r) //2
      {	
        mid=(l+r)/2;  //1
        if(f[mid]>a[i]) r=mid; 
        //如果仍然小于之前所记录的最小末尾，那么不断
        //向前寻找(因为是最长上升子序列，所以f数组必
        //然满足单调) 
        else l=mid+1; //l=mid+1=2;
      }
      f[l]=min(a[i],f[l]);//更新最小末尾 f[2]=min(299,300)=299
    }
  }
  cout<<len<<endl;
```

#### 友好城市 | [P2782](https://www.luogu.com.cn/problem/P2782)

要满足题目中的条件，需要保证南岸序列和北岸序列**单调上升**（题目中交代了坐标不会重合）。

我们可以按北岸坐标大小对城市进行排序，来保证北岸序列单调上升；

然后，南岸序列的**最长上升子序列**长度就是能够批准的航线条数。

```C++
#include<iostream>
#include<algorithm>
using namespace std;
struct city
{
    int n,s;
}c[200005];
bool cmp(city a,city b){return a.n<b.n;};
int l[200005],ans=0,n;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) cin>>c[i].n>>c[i].s;
    sort(c+1,c+n+1,cmp);
    for(int i=1;i<=n;i++)
    {
        if(c[i].s>l[ans]) l[++ans]=c[i].s;
        else *lower_bound(l,l+ans+1,c[i].s)=(c[i].s);
    }
    cout<<ans<<endl;
    return 0;
}
```

#### [HAOI2006]数字序列 | [P2501](https://www.luogu.com.cn/problem/P2501)

```C++
#include <vector>
#include <cstdio>
#include <ctype.h>
#include <cstring>
#include <algorithm>
#define ll long long
const int kMaxn = 3e4 + 5e3;
const int kInf = 1e9 + 2077;
int n, lth, b[kMaxn];
int minn[kMaxn], f[kMaxn];
ll g[kMaxn], pre[kMaxn], suf[kMaxn];
std :: vector <int> end[kMaxn];
inline int read() {
  int f = 1, w = 0; char ch = getchar();
  for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1;
  for (; isdigit(ch); ch = getchar()) w = (w << 3) + (w << 1) + (ch ^ '0');
  return f * w;
}
int main() {
  n = read();
  for (int i = 1; i <= n; ++ i) b[i] = read() - i; 
  b[0] = - kInf, b[n + 1] = kInf;
  
  for (int i = 1; i <= n + 1; ++ i) { 
    int l = 0, r = lth;
    while (l < r) {
      int mid = (l + r + 1) >> 1;
      if (minn[mid] <= b[i]) l = mid;
      else r = mid - 1;
    }
    if (l == lth) ++ lth;
    f[i] = l + 1;
    minn[l + 1] = b[i];
    end[f[i]].push_back(i); 
  } 
  
  end[0].push_back(0);
  memset(g, 20, sizeof(g));
  g[0] = 0;
  for (int i = 1; i <= n + 1; ++ i) {
    for (int j = 0, size = end[f[i] - 1].size(); j < size; ++ j) {
      int from = end[f[i] - 1][j];
      if (from > i || b[from] > b[i]) continue ; 
      pre[from] = suf[i - 1] = 0; 
      for (int k = from + 1; k <= i - 1; ++ k) {
        pre[k] = pre[k - 1] + abs(b[k] - b[from]);
      }
      for (int k = i - 2; k >= from; -- k) {
        suf[k] = suf[k + 1] + abs(b[k + 1] - b[i]);
      }
      for (int k = from; k <= i - 1; ++ k) { 
        g[i] = std :: min(g[i], g[from] + pre[k] + suf[k]); 
      }
    }
  }
  printf("%d\n%lld\n", n - lth + 1, g[n + 1]);
  return 0;
}
```



### 最长公共子序列（LCS）(P1439)

$\mathcal{O}(n^2)$:

```C++
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
int n;
int a1[100005],a2[100005];
int dp[100005];
int main()
{
    cin>>n;
    memset(dp,0,sizeof(dp));
    for(int i=1;i<=n;i++)
        cin>>a1[i];
    for(int j=1;j<=n;j++)
        cin>>a2[j];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(a1[i]==a2[j])
                dp[j]=dp[j-1]+1;
            else
                //dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
                dp[j]=max(dp[j],dp[j-1]);
        }
    }
    cout<<dp[n]<<endl;
    return 0;
}

```

$\mathcal{O}(n\log n)$ :

因为两个序列都是$1～n$的全排列，那么两个序列元素互异且相同，也就是说只是位置不同罢了，那么我们通过一个map数组将A序列的数字在B序列中的位置表示出来——

因为**最长公共子序列是按位向后比对的，所以a序列每个元素在b序列中的位置如果递增，就说明b中的这个数在a中的这个数整体位置偏后**，可以考虑纳入LCS——那么就可以转变成nlogn求用来记录新的位置的map数组中的**LIS**。

```C++
#include<iostream>
#include<cstdio>
using namespace std;
int a[100001],b[100001],map[100001],f[100001];
int main()
{
  int n;
  cin>>n;
  for(int i=1;i<=n;i++){scanf("%d",&a[i]);map[a[i]]=i;}
  for(int i=1;i<=n;i++){scanf("%d",&b[i]);f[i]=0x7fffffff;}
  int len=0;
  f[0]=0;
  for(int i=1;i<=n;i++)
  {
    int l=0,r=len,mid;
    if(map[b[i]]>f[len])f[++len]=map[b[i]];
    else 
    {
      while(l<r)
      {	
        mid=(l+r)/2;
        if(f[mid]>map[b[i]])r=mid;
        else l=mid+1; 
      }
      f[l]=min(map[b[i]],f[l]);
    }
  }
  cout<<len;
  return 0;
}
```



### 编辑距离（P2758）

***Solution:***

dp（i，j）代表字符串A的前i个字符（包括第i个）变为字符串B的前j个（包括第j个）需要多少步

- 删除：删最后一个，dp(i-1,j)+1 
- 添加：可以理解成把B[j]删掉，dp(i,j-1)+1
- 替换：如果最后的字符一样，dp(i-1,j-1);如果不一样，dp(i-1,j-1)+1

```C++
#include<iostream>
#include<cstring>
using namespace std;
string A,B;
char s1[2005],s2[2005];
int edit[2005][2005];
int dp(int i,int j){
    if(edit[i][j]!=-1) return edit[i][j];
    if(i==0) return edit[i][j]=j;
    if(j==0) return edit[i][j]=i;
    int bonus=1;
    if(s1[i]==s2[j]) bonus=0;
    return edit[i][j]=min(min(dp(i-1,j)+1,dp(i,j-1)+1),dp(i-1,j-1)+bonus);
}
int main(){
    cin>>A>>B;
    memset(edit,-1,sizeof(edit));
    int len1=A.length(),len2=B.length();
    for(int i=0;i<len1;i++ ) s1[i+1]=A[i];
    for(int i=0;i<len2;i++) s2[i+1]=B[i];
    dp(len1,len2);
    cout<<edit[len1][len2]<<endl;
    return 0;
}
```

### 带通配符的字符串匹配

通配符是一类键盘字符，当我们不知道真正字符或者不想键入完整名字时，常常使用通配符代替一个或多个真正字符。通配符有问号(?)和星号(\*)等，其中，“?”可以代替一个字符，而“*”可以代替零个或多个字符。

你的任务是，给出一个带有通配符的字符串和一个不带通配符的字符串，判断他们是否能够匹配。

```C++
#include<iostream>
using namespace std;
string a,b;
#include<cstring>
bool dp[25][25];
int main()
{
    cin>>a>>b;
    dp[0][0]=true;
    for(int i=1;i<=a.size();i++)
    {
        if(a[i-1]=='*') dp[0][i]=true;
        else break;
    }
    for(int i=1;i<=b.size();i++)
    {
        for(int j=1;j<=a.size();j++)
        {
            if(a[j-1]=='*')
            {
                dp[i][j] = dp[i - 1][j] || dp[i][j - 1] || dp[i - 1][j - 1];
            }
            else
            {
                dp[i][j] = (a[j-1]==b[i-1]||a[j-1]=='?')&&dp[i-1][j-1];
            }
        }
    }
    if(dp[b.size()][a.size()])
    cout<<"matched"<<endl;
    else cout<<"not matched"<<endl;
    return 0;
}
```

## 区间DP

### 删数 | [P2426](https://www.luogu.com.cn/probleam/P2426)

```C++
#include <iostream>
#include <algorithm>
using namespace std;

int n, val[105], dp[105];

int Val(int l, int r) {
  return abs(val[l] - val[r]) * (r - l + 1);
}

int main() 
{
  scanf("%d", &n);
  for(int i = 1; i <= n; ++i) scanf("%d", &val[i]);
  for(int i = 1; i <= n; ++i) {
    dp[i] = max(dp[i], dp[i - 1] + val[i]);
    for(int j = 2; j <= i; ++j)
      dp[i] = max(dp[i], dp[i - j] + Val(i - j + 1, i));
  }
  printf("%d\n", dp[n]);
  return 0;
}

```

### [NOIP2003 提高组] 加分二叉树 | [P1040](https://www.luogu.com.cn/problem/P1040)

我们可以枚举根来更新最大值。中序遍历有个特点，在中序遍历这个序列上，某个点左边的序列一定是这个点的左子树，右边的序列，一定在这个点的右子树。

$root[i,j]$ 表示 $[i,j]$ 这段序列的根，递归输出先序遍历。注意初始化，$f[i][i]=v[i]$，当序列只有一个元素时，$f[i][i]$ 等于这个点本身

的权值，当 $l==r-1$ 时，此时是空树设为1。

```C++
#include<iostream>
using namespace std;
int n,v[39],f[47][47],i,j,k,root[49][49];
void print(int l,int r){
    if(l>r)return;
    if(l==r){printf("%d ",l);return;}
    printf("%d ",root[l][r]);
    print(l,root[l][r]-1);
    print(root[l][r]+1,r);
}
int main() {
    scanf("%d",&n);
    for( i=1; i<=n; i++) scanf("%d",&v[i]);
    for(i=1; i<=n; i++) {f[i][i]=v[i];f[i][i-1]=1;}
    for(i=n; i>=1; i--)
        for(j=i+1; j<=n; j++)
            for(k=i; k<=j; k++) {
                if(f[i][j]<(f[i][k-1]*f[k+1][j]+f[k][k])) {
                    f[i][j]=f[i][k-1]*f[k+1][j]+f[k][k];
                    root[i][j]=k;
                }
            }
    printf("%d\n",f[1][n]);
    print(1,n);
    return 0;
}
```

### [HNOI2010]合唱队 | [P3205](https://www.luogu.com.cn/problem/P3205)

$f[i][j][0]$表示的是第 $i$ 人从左边进来的方案数, $f[i][j][1]$ 表示的是第 $j$人从右边进来的方案数

从左边进来肯定前1个人比他高，前1个人有2种情况，要么在 $i+1$ 号位置，要么在 $j$ 号位置。

右边同理。

``` C++
#include <iostream>
using namespace std;
int f[2010][2010][2],a[2010];
int main(){
  int n;
  cin>>n;
  for(int i=1;i<=n;i++)cin>>a[i];
  for(int i=1;i<=n;i++)f[i][i][0]=1;
  for(int len=1;len<=n;len++)
    for(int i=1,j=i+len;j<=n;i++,j++){
      if(a[i]<a[i+1])f[i][j][0]+=f[i+1][j][0];
      if(a[i]<a[j])f[i][j][0]+=f[i+1][j][1];
      if(a[j]>a[i])f[i][j][1]+=f[i][j-1][0];
      if(a[j]>a[j-1])f[i][j][1]+=f[i][j-1][1];
      f[i][j][0]%=19650827;
      f[i][j][1]%=19650827;
  }
  cout<<(f[1][n][0]+f[1][n][1])%19650827;
  return 0;
}
```

### [NOI1995] 石子合并 | [P1880](https://www.luogu.com.cn/problem/P1880)

```C++
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
using namespace std;
const int INF=2147483647;
inline int read()
{
    int x=0,k=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')k=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
    return x*k;
}
int f[302][302],g[302][302],a[302],sum[302],n;//f为最小得分，g为最大得分
int main()
{
    n=read();
    rep(i,1,n)
    {
        a[i]=read();
        a[i+n]=a[i];
    }
    rep(i,1,2*n)sum[i]=sum[i-1]+a[i];
    rep(len,1,n-1)		//遍历的是区间长度，有点有点
        for(int l=1,r=l+len;l<2*n&&r<2*n;l++,r=l+len)
        {
            rep(p,l,r-1)
            {
                f[l][r]=f[l][r]?min(f[l][r],f[l][p]+f[p+1][r]+sum[r]-sum[l-1]):f[l][p]+f[p+1][r]+sum[r]-sum[l-1];
                g[l][r]=max(g[l][r],g[l][p]+g[p+1][r]+sum[r]-sum[l-1]);
            }
        }
    int ansmax=-INF,ansmin=INF;
    rep(i,1,n)ansmax=max(ansmax,g[i][i+n-1]),ansmin=min(ansmin,f[i][i+n-1]);
    printf("%d\n%d\n",ansmin,ansmax);
    return 0;
}
```

### [NOIP2006 提高组] 能量项链 | [P1063](https://www.luogu.com.cn/problem/P1063)

```C++
#include<bits/stdc++.h>
using namespace std;
int n,e[300],s[300][300],maxn=-1;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){cin>>e[i];e[i+n]=e[i];}
    //珠子由环拆分为链，重复存储一遍
    for(int i=2;i<2*n;i++){
      for(int j=i-1;i-j<n&&j>=1;j--){//从i开始向前推
        for(int k=j;k<i;k++)//k是项链的左右区间的划分点 
          s[j][i]=max(s[j][i],s[j][k]+s[k+1][i]+e[j]*e[k+1]*e[i+1]);
          //状态转移方程：max(原来能量，左区间能量+右区间能量+合并后生成能量）  
          if(s[j][i]>maxn)maxn=s[j][i];//求最大值 
        }
    } 
    cout<<maxn<<endl;
    return 0;
}
```

### [USACO16OPEN]248 G | [P3146](https://www.luogu.com.cn/problem/P3146)

```C++
#include<iostream>
#include<cstdio>

using namespace std;

const int maxn = 255;

int n, val, ans;
int f[maxn][maxn];  //f代表完全合并!!!!!

inline int read()
{
  int s = 0, w = 1;
  char ch = getchar();
  for(; ch < '0' || ch > '9'; ch = getchar()) if(ch == '-') w = -1;
  for(; ch <= '9' && ch >= '0'; ch = getchar()) s= s * 10 + ch - '0';
  return s * w;
}

int main()
{
  n = read();
  for(register int i = 1; i <= n; i++) val = read(), f[i][i] = val; 
  for(register int len = 2; len <= n; len++) 
  {
    for(register int i = 1; i <= n - len + 1; i++)   
    {
      int j = i + len - 1;
      for(register int pos = i; pos < j; pos++)    
      {
        if(f[i][pos] == f[pos+1][j] && f[i][pos] != 0 && f[pos+1][j] != 0)            
       	{
          f[i][j] = max(f[i][j], f[i][pos] + 1);
          ans = max(ans, f[i][pos] + 1);     
      	}
      } 
    }
  }
  cout << ans << endl;
  return 0;
}
```

### [CQOI2007]涂色 | [P4170](https://www.luogu.com.cn/problem/P4170)

```C++
#include<iostream>
using namespace std;
string s;
int f[55][55];
int main()
{
    cin>>s;
    /*
    RGR:第一次刷RRR就相当于直接弄掉了首位或者末位:min(f[i][j-1],f[i+1][j])
    */
    int l=s.length();
    for(int i=1;i<=l;i++) f[i][i]=1;
    for(int i=l;i>=1;i--)
    {
        for(int j=i+1;j<=l;j++)
        {
            if(s[i-1]==s[j-1])
            f[i][j]=min(f[i][j-1],f[i+1][j]);
            else
            {
                f[i][j]=10000000;
                for(int k=i;k<=j-1;k++)
                f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);
            }
        } 
    }
    cout<<f[1][l]<<endl;
    return 0;;
}
```

### 关路灯 | [P1220](https://www.luogu.com.cn/problem/P1220)

用 $dp[i][j][0/1]$ 代表人关上 从 $i$ 到 $j$ 的所有路灯后位于最左/右，则：
$$
dp[l][r][0]=\min\{dp[l+1][r][0]+(\sum_{i=1}^l s_i+\sum_{i=r+1}^n s_i)\times (d[l+1]-d[l]),dp[l+1][r][1]+(\sum_{i=1}^l s_i+\sum_{i=r+1}^n s_i)\times(d[r]-d[l])\}\\
dp[l][r][1]=\min\{dp[l][r-1][1]+(\sum_{i=1}^{l-1} s_i+\sum_{i=r}^n s_i)\times (d[r]-d[r-1]),dp[l][r+1][1]+(\sum_{i=1}^{l-1} s_i+\sum_{i=r}^n s_i)\times(d[r]-d[l])\}
$$


```C++
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
inline int read()
{
    int x=0,k=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')k=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
    return x*k;
}
int dp[55][55][2],n,c,p[55],d[55],s[55];
int main()
{
    n=read(),c=read();
    rep(i,1,n)d[i]=read(),p[i]=read(),s[i]=s[i-1]+p[i];
    memset(dp,0x3f,sizeof(dp));
    dp[c][c][0]=dp[c][c][1]=0;
    per(l,c,1)
    {
        rep(r,c,n)
        {
            dp[l][r][0]=min(dp[l][r][0],dp[l+1][r][0]+(s[l]+(s[n]-s[r]))*(d[l+1]-d[l]));
            dp[l][r][0]=min(dp[l][r][0],dp[l+1][r][1]+(s[l]+(s[n]-s[r]))*(d[r]-d[l]));
            dp[l][r][1]=min(dp[l][r][1],dp[l][r-1][1]+(s[l-1]+(s[n]-s[r-1]))*(d[r]-d[r-1]));
            dp[l][r][1]=min(dp[l][r][1],dp[l][r-1][0]+(s[l-1]+(s[n]-s[r-1]))*(d[r]-d[l]));
        }
    }
    printf("%d",min(dp[1][n][0],dp[1][n][1]));
    return 0;
}
```
### [SDOI2008] Sue 的小球 | [P2466](https://www.luogu.com.cn/problem/P2466)
和关路灯基本相同，但此时考虑的是如何让减少的收益最小，最后输出 `ans-min(dp[1][n+1][1],dp[1][n+1][0])`，相当细节的是我们可以人为的增加一个节点 `a[1]`，使 `a[1].x=x0,a[1].y=a[i].v=0.0`
### [BJWC2008]雷涛的小猫 | [P1107](https://www.luogu.com.cn/problem/P1107)

```Cpp
#include <bits/stdc++.h>
using namespace std;
int n,h,de;
int a[5009][2009],dp[5009][2009],pre[5009];
int main()
{
  cin>>n>>h>>de;
  for(int i=1;i<=n;i++)
  {
    int t,zz;
    scanf("%d",&t);
    while(t--){
    scanf("%d",&zz);
    a[i][zz]++;
    }
  }
  int maxn=0;
  for(int j=h;j>=0;j--)
  {
    for(int i=1;i<=n;i++)
    {
      dp[i][j]=a[i][j]+dp[i][j+1];
      dp[i][j]=max(dp[i][j],pre[j+de]+a[i][j]);
      pre[j]=max(pre[j],dp[i][j]);
      maxn=max(maxn,dp[i][j]);
    }
  }
  cout<<maxn;
}
```



## 树形DP

### 没有上司的舞会 | [P1352](https://www.luogu.com.cn/problem/P1352)

设 $f[x][0]$表示以 $x$ 为根的子树,且 $x$ 不参加舞会的最大快乐值, $f[x][1]$表示以 $x$ 为根的子树，且 $x$ 参加了舞会的最大快乐值，$y$ 是 $x$ 的儿子,则：
$$
f[x][0]=\sum \max(f[y][0],f[y][1]) \\
f[x][1]=\sum f[y][0]+r[x]
$$

```C++
#include<iostream>
using namespace std;
#define MAXN 6005
int h[MAXN];
int v[MAXN];
vector<int> son[MAXN];
int f[MAXN][2];
void dp(int x)
{
  f[x][0]=0;
  f[x][1]=h[x];
  for(int i=0;i<son[x].size();i++)
  {
    int y=son[x][i];
    dp(y);
    f[x][0]+=max(f[y][0],f[y][1]);
    f[x][1]+=f[y][0];
  }
}
int main()
{
  int n;
  cin>>n;
  for(int i=1;i<=n;i++) cin>>h[i];
  for(int i=1;i<=n-1;i++)
  {
    int x,y;
    cin>>x>>y;
    son[y].push_back(x);
    v[x]=1;
  }
  int root;
  for(int i=1;i<=n;i++)
  if(!v[i]) {root=i;break;}
  dp(root);
  cout<<max(f[root][0],f[root][1])<<endl;
  return 0;
}
```

### 最大子树和| [P1122](https://www.luogu.com.cn/problem/P1122)

我们用 $f[i]$ 记录 **以 $i$ 为根的子树中点权和最大的一棵子树（或只选根）**，$a[i]$ 是输入的点权。

因为这样做的话最后要从每个 $f[i]$ 中找出最大的数作为答案输出，所以 **选择哪个点为根对结果没有影响**，毕竟 **任一连通分量在任一时刻总是可以看成一棵以某个点为根的树**。

那不妨设节点1为根，点0为它的父亲。

根据定义，在走到点 $u$ 时，$f[u]$ 所表示的连通分量中必包含点 $u$ ，所以**把 $f[u]$ 初始化为点 $u$ 的点权 $a[u]$**。

接下来，对于 $u$ 的每一棵子树，我们都可以选择剪枝或不剪枝。对于 $u$ 的一个儿子 $v$ ，显然**当 $f[v]<0$ 时就剪断 u−v 这条枝，反之**。故：
$$
f(u)=a[u]+(f[v]>0?f[v]:0)
$$

```C++
#include <vector>
#include<iostream>
using namespace std;
int n,a[16005],f[16005],ans=-2147483647;
vector <int> E[16005];
void dfs(int u,int fa)
{
    f[u]=a[u];
    for(int i=0;i<E[u].size();i++)
    {
        int t=E[u][i];
        if(t!=fa)
        {
            dfs(t,u);
            if(f[t]>0)
                f[u]+=f[t];
        }
    }
}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=1;i<n;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        E[u].push_back(v);
        E[v].push_back(u);
    }
    dfs(1,0);
    for(int i=1;i<=n;i++)
        ans=max(ans,f[i]);
    printf("%d",ans);
    return 0;
}
```
### 有线电视网 | [P1273](http://www.luogu.com.cn/problem/P1273)

```C++
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=3010;
int n,m,EdgeCnt=0;
int dp[N][N],val[N],a[N],t[N];
struct Edge{
    int to,w,next;
}e[N*N];
int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
void addedge(int u,int v,int w){
    int p=++EdgeCnt;
    e[p].to=v;e[p].w=w;e[p].next=a[u];
    a[u]=p;
}
int dfs(int u){
    if (u>n-m){
        dp[u][1]=val[u];
        return 1;
    }
    int sum=0;
    for (int p=a[u];p;p=e[p].next){
        int v=e[p].to;
        int tk=dfs(v);
        for (int j=0;j<=sum;j++)t[j]=dp[u][j];
        for (int j=0;j<=sum;j++)
            for (int k=0;k<=tk;k++)
                dp[u][j+k]=max(dp[u][j+k],t[j]+dp[v][k]-e[p].w);
        sum+=tk;
    }
    return sum;
}
int main(){
    n=read(),m=read();
    memset(dp,~0x3f,sizeof(dp));
    for (int u=1;u<=n-m;u++){
        int size=read();
        for (int j=1;j<=size;j++){
            int v=read(),w=read();
            addedge(u,v,w);
        }
    }
    for (int i=n-m+1;i<=n;i++)
        val[i]=read();
    for (int i=1;i<=n;i++)
        dp[i][0]=0;
    dfs(1);
    for (int i=m;i>0;i--)
        if (dp[1][i]>=0){
            printf("%d",i);
            break;
        }
    return 0;
}
```
### [USACO12FEB]Nearby Cows G|[P3047](https://www.luogu.com.cn/problem/P3047)
设 $dp[i][j]$ 表示从 $i$ 点向下 $j$ 的范围内有多少头牛，$f[i][j]$ 表示从 $i$ 点到范围为 $j$ 有多少头牛
$$ 
dp[i][j]=C_u+\sum_{v\in son_u}dp[u][j-1] \\
f[v][j]=f[fa[v]][j-1]-dp[v][j-2]+dp[v][j]
$$
```C++
#include<iostream>
#include<cmath>
#include<iomanip>
#include<string>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
#include<bitset>
#include<map>
#include<stack>
#include<list>
#include<deque>
using namespace std;

inline int read()
{
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=((s<<3)+(s<<1)+(ch^48)),ch=getchar();
    return s*w;
}

int n,k;
const int N=1e5+5;
vector< vector<int> > edge;
int c[N],dp[N][21],f[N][21];

void dfs(int x,int fa,int u){
    dp[x][u]+=c[x];
    for(int i=0;i<edge[x].size();i++){
        int y=edge[x][i];
        if(y==fa) continue;
        dp[x][u]+=dp[y][u-1];
        dfs(y,x,u);
    }
}

void cal(int x,int fa,int u){
    int w=(u-2)>=0?dp[x][u-2]:0;
    f[x][u]=f[fa][u-1]-w+dp[x][u];
    for(int i=0;i<edge[x].size();i++){
        if(fa!=edge[x][i])
        cal(edge[x][i],x,u);
    }
}

// void work(int x){
//     for(int i=0;i<edge[1].size();i++){
//         cal(edge[1][i],1,x);
//     }
// }

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    n=read(),k=read();
    edge.resize(N);
    for(int i=1;i<=n-1;i++){
        int u,v;
        u=read(),v=read();
        edge[u].push_back(v);
        edge[v].push_back(u);
    }
    for(int i=1;i<=n;i++){
        c[i]=read();
        dp[i][0]=c[i];
    }
    if(k==0){
        for(int i=1;i<=n;i++)
        cout<<c[i]<<endl;
        return 0;
    }
    for(int i=1;i<=k;i++){
        dfs(1,0,i);
        f[1][i]=dp[1][i];
    }
 
    for(int i=1;i<=n;i++) f[i][0]=c[i];
    for(int i=1;i<=k;i++){
        for(int j=0;j<edge[1].size();j++)
        cal(edge[1][j],1,i);
    }
    for(int i=1;i<=n;i++)
    cout<<f[i][k]<<endl;
    return 0;
}
```

## 状压DP

### [NOI2001] 炮兵阵地|[P2704](https://www.luogu.com.cn/problem/P2704)

用 dp[L][S][i] 表示第 $i$ 行状态为S且前一行状态为L的炮兵数，则:
$$
dp[L][S][i]=\max(dp[L][S][i],dp[FL][L][i-1]+sum(S))
$$
其中 sum(S) 表示状态S中含几个炮兵

1.判断每个位置是不是山丘：S&a[i] 结果为1则不合法
2.判断每个状态有没有炮兵在两个之内：S&(S<<1)和S&(S<<2)不为0则不合法
3.每一行之前两行有没有炮兵：S&L,S&FL不为零则不合法

代码实现：
```C++
#include<iostream>
using namespace std;
int n,m,ans,dp[(1<<10)][(1<<10)][3]/*滚动数组*/,a[105],Sum[(1<<10)];
char x;
int getsum(int S)	//当前状态 S 里面包含几个 1
{
  int tot=0;
  while(S) {if(S&1) tot++; S>>=1;}
  return tot;
}
int main()
{
  cin>>n>>m;
  for(int i=0;i<n;i++)
    for(int j=0;j<m;j++)
    cin>>x,a[i]<<=1,a[i]+=(x=='H'?1:0);	//转成二进制数
  for(int i=0;i<(1<<m);i++)
    Sum[i]=getsum(i);	//初始化 Sum 数组
  for(int S=0;S<(1<<m);S++)
    if(!(S&a[0] || (S&(S<<1)) || (S&(S<<2))))
      dp[0][S][0]=Sum[S];	//初始化
  for(int L=0;L<(1<<m);L++)
    for(int S=0;S<(1<<m);S++)
      if(!(L&S || L&a[0] || S&a[1] || (L&(L<<1)) || (L&(L<<2)) || (S&(S<<1)) || (S&(S<<2))))	
        dp[L][S][1]=Sum[S]+Sum[L];
  for(int i=2;i<n;i++)
    for(int L=0;L<(1<<m);L++)
    {
      if(L&a[i-1] || (L&(L<<1)) || (L&(L<<2))) continue;	//特判
      for(int S=0;S<(1<<m);S++)
      {
        if(S&a[i] || L&S || (S&(S<<1)) || (S&(S<<2))) continue;
        for(int FL=0;FL<(1<<m);FL++)
        {
          if(FL&L || FL&S || FL&a[i-2] || (FL&(FL<<1)) || (FL&(FL<<2)))	continue;
          dp[L][S][i%3]=max(dp[L][S][i%3],dp[FL][L][(i-1)%3]+Sum[S]);		//滚动数组的实现方法
        }
      }
    }
  for(int L=0;L<(1<<m);L++)
    for(int S=0;S<(1<<m);S++)
      ans=max(ans,dp[L][S][(n-1)%3]);	//结束状态可以是最后一行的任何状态
  cout<<ans;
  return 0;
}
```

# DFS

## 选数

已知 $n$ 个整数$x_1,x_2,\cdots,x_n$，以及1个整数 $k$  $(k<n)$。从 $n$ 个整数中任选 $k$ 个整数相加，可分别得到一系列的和。例如当 $n=4$，$k=3$，4个整数分别为3,7,12,19时，可得全部的组合与它们的和为：
$$
3+7+12=22\\
3+7+19=29\\
7+12+19=38\\
3+12+19=34\\
$$
现在，要求你计算出和为素数共有多少种。

例如上例，只有一种的和为素数：3+7+19=29。

***Solution：***

```C++
#include<iostream>
#include<string>
#include<cstring>
using namespace std;
int n,k;
long long cnt=0;
int a[25];
bool isPrime(int x)
{
    for(int i=2;i*i<=x;i++)
    {
        if(x%i==0)
            return false;
    }
    return true;
}
//x代表选取数的个数，startx是下一个选出的数的下界
void dfs(int sum,int x,int startx)
{
    if(x==k)
    {
        if(isPrime(sum))
            cnt++;
        return;
    }
    for(int i=startx;i<n;i++)
        dfs(sum+a[i],x+1,i+1);//例如我们已经选取了3，7 为了去重，要选取比7大的数
    return;
}
int main()
{
    cin>>n>>k;
    for(int i=0;i<n;i++)
        cin>>a[i];
    dfs(0,0,0);
    cout<<cnt<<endl;
    return 0;
}

```

## 八皇后

```C++
#include<iostream>
using namespace std;
int cnt=0,n;
bool cover[3][28]={0};
int ans[14];
void dfs(int line)
{
    if(line>n)
    {
        cnt++;
        for(int i=1;i<=n;i++)
        cout<<ans[i]<<" ";
        cout<<endl;
        return;
    }
    for(int j=1;j<=n;j++)
    {
        if((!cover[0][j])&&(!cover[1][line+j])&&(!cover[2][line-j+n]))
        {
            ans[line]=j;
            cover[0][j]=true,cover[1][line+j]=true,cover[2][line-j+n]=true;
            dfs(line+1);
            cover[0][j]=false,cover[1][line+j]=false,cover[2][line-j+n]=false;            
        }
    }
}
int main()
{
    cin>>n;
    dfs(1);
    cout<<cnt<<endl;
    return 0;
}
```

## 单词接龙

单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 `beast` 和 `astonish`，如果接成一条龙则变为 `beastonish`，另外相邻的两部分不能存在包含关系，例如 `at` 和 `atide` 间不能相连。

输入的第一行为一个单独的整数 n 表示单词数，以下 n 行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在。

只需输出以此字母开头的最长的“龙”的长度

```C++
#include<iostream>
#include<cstring>
using namespace std;
string str[20];
int n,length=0;
int used[20];
int get(string now,string next)
{
    for(int i=1;i<now.length()&&i<next.length();i++)
    {
        int flag=1;
        for(int j=0;j<i;j++)
        {
            if(now[now.length()-i+j]!=next[j]) flag=0;
        }
        if(flag)
        return i;
    }
    return 0;
}
void dfs(string s,int l)	//土曾长字符串 dfs string s,int l
{
    length=length<l?l:length;
    for(int i=0;i<n;i++)
    {
        if(used[i]>=2) continue;
        int c=get(s,str[i]);
        if(c>0)
        {
            used[i]++;
            dfs(str[i],l+str[i].length()-c);
            used[i]--;
        }
    }
}
int main()
{
    memset(used,0,sizeof(used));
    cin>>n;
    for(int i=0;i<=n;i++)
    {
        cin>>str[i];
    }
    dfs(' '+str[n],1);
    cout<<length<<endl;
    return 0;
}
```

## 求细胞数目

一矩形阵列由数字 0 到 9 组成，数字 1 到 9 代表细胞，细胞的定义为沿细胞数字上下左右若还是细胞数字则为同一细胞，求给定矩形阵列的细胞个数。输入：

第一行两个整数代表矩阵大小 n 和 m。

接下来 n 行，每行一个长度为 m 的只含字符 `0` 到 `9` 的字符串，代表这个 n×m 的矩阵。

```C++
#include<iostream>
using namespace std;
char map[105][105];
int n,m,cnt=0;
int dirx[4]={0,0,1,-1};
int diry[4]={1,-1,0,0};
void dfs(int x,int y)
{
    map[x][y]='0';
    for(int w=0;w<4;w++)
    {
        int xx=x+dirx[w];
        int yy=y+diry[w];
        if(xx>=0&&xx<=n-1&&yy>=0&&yy<=m-1&&map[xx][yy]!='0')
            dfs(xx,yy);
    }
    return;
}
int main()
{
    cin>>n>>m;
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
            cin>>map[i][j];
    }
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
        {
            if(map[i][j]!='0')
            {
                dfs(i,j);
                cnt++;
            }
        }
    }
    cout<<cnt<<endl;
    return 0;
}

```

## [NOIP1999 提高组] 邮票面值设计|[P1021](https://www.luogu.com.cn/problem/P1021)

```C++
#include<iostream>
#include<cstring>//头文件
using namespace std;
int a[17],n,k,ans[17],maxn;//a[]表示这种方法的邮票，ans[]表示如今取得的解即要输出的
int dp(int t,int mx)
{
    int f[50000];//f[i]为拼i所需的最少数的个数
    f[0]=0;//边界
    for(int i=1;i<=a[t]*n;i++)
      f[i]=50000;//赋初值赋一个尽可能地大就可以了
    for(int i=1;i<=t;i++)            //从第一位找到目前的位数把所有已找的邮票都枚举 
      for(int j=a[i];j<=a[t]*n;j++)   //因为不可能找到比自己小的数，所以从自己开始找 
        f[j]=min(f[j],f[j-a[i]]+1);    //比较上几次已找到的最小需要位数和即将要找的相比较，取较小值 
    for(int i=1;i<=a[t]*n;i++)
      if(f[i]>n)//如果所需最小的个数大于n就意味着这种情况不符合，但f[i-1]是符合的,所以不符合返回i-1
        return i-1;
    return a[t]*n;//如果到a[t]*n的f[i]都满足意味着能取到的最大连续数就是a[t]*n
}
void dfs(int t,int mx){              // 为什么全部找完：因为多几张邮票肯定比少几张邮票可能的情况多，所以全部找完是最好的  
    if(t==k+1){        //如果所有邮票数已经找完，那么就和 maxn比较谁更大   
        if(mx>maxn){
            maxn=mx;
            for(int i=1;i<=t-1;i++)
              ans[i]=a[i];} //保存所需要的邮票面值  
        return;
    }
    for(int i=a[t-1]+1;i<=mx+1;i++){  //继续找：为了避免重复，下一张邮票要比上一张邮票大，所以边界是a[t-1]+1，同时它不能比最大连续值+1还大，不然最大连续值的下一个数就永远连不起来了 
      a[t]=i;
      int x=dp(t,mx);   //动归寻找此时的最大连续数 
      dfs(t+1,x);
    }
}
int main(){
    cin>>n>>k;
    dfs(1,0);  //先从第一张开始找，第一张前面没有数，所以所连续的最大数为 0 
    for(int i=1;i<=k;i++)//输出 注意打空格以及大写换行即可
      cout<<ans[i]<<" ";
    cout<<endl;
    cout<<"MAX="<<maxn<<endl;
    return 
```
## [NOIP2002 提高组] 矩形覆盖 | [P1034](https://www.luogu.com.cn/problem/P1034)
枚举每个矩形
```C++
#include <iostream>
#include<climits>
#define N 55
using namespace std;

int n, k, x[N], y[N], ans = INT_MAX >> 2;
struct mat {
  int lx, ly, rx, ry;
  bool cnt;
  void add(int x, int y) {
    if(!cnt) {
      lx = rx = x;
      ly = ry = y;
      cnt = 1;
    } else {
      if(x < lx) lx = x;
      else if(x > rx) rx = x;
      if(y > ly) ly = y;
      else if(y < ry) ry = y;
    }
  }
  bool inmat(int x, int y) const {
    return lx <= x && x <= rx && ry <= y && y <= ly;
  }
  int operator() () {
    if(!cnt) return 0;
	  return (rx - lx) * (ly - ry);
  }
  bool operator* (const mat &o) {
    if(!cnt || !o.cnt) return 0;
    return o.inmat(lx, ly) || o.inmat(lx, ry) ||o.inmat(rx, ly) || o.inmat(rx, ry);
  }
}km[5];

bool check() {
  for(int i = 1;i <= k;i++)
    for(int j = i + 1;j <= k;j++)
      if(km[i] * km[j]) return 0;
  return 1;
}

void dfs(int i, int area) {
  if(area >= ans) return;
  if(i == n) {
    if(check())
    if(ans > area) ans = area;
      return;
  }
  mat tmp;
  for(int j = 1;j <= k;j++) {
    tmp = km[j];
    km[j].add(x[i], y[i]);
    dfs(i + 1, area - tmp() + km[j]());
    km[j] = tmp;
  }
}

int main() {
  scanf("%d%d", &n, &k);
  for(int i = 0;i < n;i++)
    scanf("%d%d", x + i, y + i);
  dfs(0, 0);
  printf("%d", ans);
  return 0;
}
```
## 记忆化搜索

### 滑雪

```C++
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
int n,m,a[201][201],s[201][201],ans;
int dfs(int x,int y){
    if(s[x][y])return s[x][y];//记忆化搜索
    s[x][y]=1;
    for(int i=0;i<4;i++)
    {  int xx=dx[i]+x;
       int yy=dy[i]+y;
       if(xx>0&&yy>0&&xx<=n&&yy<=m&&a[x][y]>a[xx][yy]){
       	  dfs(xx,yy);
          s[x][y]=max(s[x][y],s[xx][yy]+1);
       }
    }
    return s[x][y];
}
int main()
{	
   scanf("%d%d",&n,&m);
   for(int i=1;i<=n;i++)
     for(int j=1;j<=m;j++)
       scanf("%d",&a[i][j]);
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        ans=max(ans,dfs(i,j));
    printf("%d",ans);
    return 0;
}
```

### 最大食物链计数（P4017）

```C++
#include<bits/stdc++.h>
using namespace std;
const int mod=80112002;
bool nHst[5050];
//false -> 食物链顶端
vector<int>Eat[5050];
int dp[5050];
int n,m;
int ans;
int dfs(int now){
    if(!Eat[now].size()) return dp[now]=1;
    int res=0;
    for(int i=0;i<Eat[now].size();i++){
        int &nxt=Eat[now][i];
        res+=dp[nxt]?dp[nxt]:dfs(nxt);
        res%=mod;
    }
    return dp[now]=res;
}
int main(){
    cin>>n>>m;
    int x,y;
    while(m--){
        scanf("%d%d",&x,&y);
        Eat[y].push_back(x);
        nHst[x]=true; //被吃啦
    }
    for(int i=1;i<=n;i++) if(!nHst[i])
        ans=(ans+dfs(i))%mod;
    cout<<ans;
    return 0;
}
```



## 双向迭代加深

单向迭代加深：控制dfs的最大深度，深度超过最大深度则返回。由于时间复杂度几乎完全由搜索树的最后一层决定，因此它和BFS只有常数级别的差距，以此换来的优势是：空间占用小，有时候方便剪枝，方便传参等。

双向迭代加深就是从起点和终点一起搜。

```C++
int D;
bool found;
template<class T>
void dfs(T x,int d,int dir)
{
  if(H[x]+dir==3)
    found=true;
  H[x]=dir;
  if(d==D)
    return;
  //...递归搜索
}
int main()
{
  //...
  while(D<=MAXD/2)
  {
    dfs(st,0,1);
    if(found)
      //...
    dfs(ed,0,2);
    if(found)
      //...
    D++;
  }
}
```

### 八数码难题

在3×3的棋盘上，摆有八个棋子，每个棋子上标有1至8的某一数字。棋盘中留有一个空格，空格用0来表示。空格周围的棋子可以移到空格中。要求解的问题是：给出一种初始布局（初始状态）和目标布局（为了使题目简单,设目标状态为123804765），找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变

```C++
#include<iostream>
#include<unordered_map>
using namespace std;
int e[10]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000},D;
int ed=123804765,st,p=0;
bool found=false;
unordered_map<int,int> H;
int at(int x,int i) //找0的位置
{
  return x%e[i+1]/e[i];
}
int swap_at(int x,int p,int i)
{
  return x-at(x,i)*e[i]+at(x,i)*e[p];
}
void dfs(int x,int p,int d,int dir)
{
  if(H[x]+dir==3)
    found=true;
  H[x]=dir;
  if(d==D)
    return;
  if(p/3) 
    dfs(swap_at(x,p,p-3),p-3,d+1,dir);
  if(p/3!=2)
    dfs(swap_at(x,p,p+3),p+3,d+1,dir);
  if(p%3)
    dfs(swap_at(x,p,p-1),p-1,d+1,dir);
  if(p%3!=2)
    dfs(swap_at(x,p,p+1),p+1,d+1,dir);
}
int main()
{
  cin>>st;
  for(;at(st,p);++p); 
  while(1)
  {
    dfs(st,p,0,1);
    if(found)
    {
      cout<<2*D-1<<endl;
      break;
    }
    dfs(ed,4,0,2);
    if(found)
    {
      cout<<D*2<<endl;
      break;
    }
    D++;
  }
  return 0;
}
```

## dp+DFS

现有 n 个砝码，重量分别为 $a_i$，在去掉 m 个砝码后，问最多能称量出多少不同的重量（不包括 0）。砝码只能放在一边

***Solution***:

先dfs删去m个砝码，然后开始dp:
$$
f[i][j]=f[i-a[i]][j-1]||f[i][j-1]
$$
含义：$f[i][j]$ 为 当前选取到了第 $j$ 个砝码，如果通过之前的砝码可以称量出重量 $i$ 那么其值为 $\text{true}$ ，最后true的个数即为组合数

```C++
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=22;
const int maxm=2010;
int n,m,a[maxn],ans,tot,ret;
bool tf[maxn],f[maxm];
void dp()
{
    memset(f,0,sizeof f);f[0]=true;ans=0;tot=0;
    for(int i=0;i<n;i++)
    {
        if(tf[i])continue;
        for(int j=tot;j>=0;j--)if(f[j]&&!f[j+a[i]])f[j+a[i]]=true,ans++;
        tot+=a[i];
    }
    ret=max(ans,ret);
}
void dfs(int cur,int now)
{
    if(now>m)return;
    if(cur==n){if(now==m)dp();return;}
    dfs(cur+1,now);
    tf[cur]=true;
    dfs(cur+1,now+1);
    tf[cur]=false; 
} 
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++)scanf("%d",a+i);
    dfs(0,0);
    printf("%d\n",ret);
    return 0;
}
```



# BFS

## 求细胞数目

题目见BFS

```C++
#include<iostream>
#include<deque>
#include<cstring>
using namespace std;
char map[105][105];
int m,n,cnt=0;
int used[105][105];
int dirx[4]={0,0,1,-1},diry[4]={1,-1,0,0};
struct pos
{
    int x,y;
};
deque<pos> q;
void bfs(int a,int b)
{
    pos head;
    head.x=a;
    head.y=b;
    used[a][b]=1;
    q.push_back(head);
    while(!q.empty())
    {
        pos now=q.front();
        for(int i=0;i<4;i++)
        {
            pos next=now;
            next.x+=dirx[i];
            next.y+=diry[i];
            if(next.x>=0&&next.y>=0&&next.x<=n-1&&next.y<=m-1&&map[next.x][next.y]!='0'&&used[next.x][next.y]==0)
            {
                used[next.x][next.y]=1;
                q.push_back(next);
            }
        }
        q.pop_front();
    }
}
int main()
{
    memset(used,0,sizeof(used));
    cin>>n>>m;
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
            cin>>map[i][j];
    }
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
        {
            if(map[i][j]!='0'&&used[i][j]==0)
            {
                bfs(i,j);
                cnt++;
            }
        }
    }
    cout<<cnt<<endl;
    return 0;
}

```

## 01迷宫

有一个仅由数字0与1组成的n×n格迷宫。若你位于一格0上，那么你可以移动到相邻4格中的某一格1上，同样若你位于一格1上，那么你可以移动到相邻4格中的某一格0上。

你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。

```C++
#include<iostream>
#include<deque>
using namespace std;
int n,m,cnt,x,y,num;
char map[1005][1005];
int dirx[4]={0,0,1,-1},diry[4]={1,-1,0,0};
int flag[1001][1001],size[1000001];
//flag数组保存各个点所在的连通图，以及是否已经处理过，a数组保存各个连通图的大小
struct p
{
    int a,b;
};
deque<p> q;
void bfs(int x,int y)
{
    p head;
    head.a=x;
    head.b=y;
    q.push_back(head);
    while(!q.empty())
    {
        p now=q.front();
        for(int i=0;i<4;i++)
        {
            p next=now;
            next.a+=dirx[i];
            next.b+=diry[i];
            if(next.a>=1&&next.a<=n&&next.b>=1&&next.b<=n&&flag[next.a][next.b]==0&&map[next.a][next.b]!=map[now.a][now.b])
            {
                flag[next.a][next.b]=num;
                q.push_back(next);
                cnt++;
            }
        }
        q.pop_front();
    }
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
            cin>>map[i][j];
    }
    for(int i=0;i<m;i++)
    {
        cin>>x>>y;
        if(flag[x][y])
            cout<<size[flag[x][y]]<<endl;
        else
        {
            cnt=1;
            flag[x][y]=++num;
            bfs(x,y);
            size[num]=cnt;
            cout<<cnt<<endl;
        }
    }
    return 0;
}

```

## 双向BFS

轮流拓展两个队列，用哈希表记录当前的搜索情况，给从两个方向拓展的节点以不同的标记，当某点被两种标记同时标记时搜索结束

```C++
queue<T> Q[3];
bool found=false;
Q[1].push(st);//st为起始状态
Q[2].push(ed);//ed为终止状态
for(int d=0;d<D+2;++d)//D是最大深度
{
  int dir=(d&1)+1;//取方向
  sz=Q[dir].size();
  for(int i=0;i<sz;i++)
  {
    auto x=Q[dir].front();
    Q[dir].pop();
    if(H[x]+dir==3) //3=1+2
    {
      found=true;
    }
    H[x]=dir;
  }
  if(found)
    //...
}
```

## 字符变换

已知有两个字串 A,B 及一组字串变换的规则（至多 6 个规则）:

A1→B1

A2→B2

规则的含义为：在 A 中的子串 A1 可以变换为 B1，A2 可以变换为 B2⋯。

```C++
#include <iostream>
#include <string>
#include <cstring>
#include <queue>
#include <map>
#define maxn 15
using namespace std;
struct node{//方便搜索，也可以使用pair简化
    string str;
    int step;
};

string a,b;
string orginal[maxn];
string translated[maxn];
int n,ans;
map<string,int> ma;//很重要的东西，用来判重，否则会TLE在第3点和第5点

string trans(const string &str,int i,int j){//借鉴了stdcall大爷的思想
    string ans = "";
    if (i+orginal[j].length() > str.length())
        return ans;

    for (int k=0; k < orginal[j].length();k++)
        if (str[i+k] != orginal[j][k])
            return ans;

    ans = str.substr(0,i);
    ans+=translated[j];
    ans+=str.substr(i+orginal[j].length());
    return ans;
}

void bfs(){//一个平淡无奇的bfs过程
    queue <node> q;
    node s;
    s.str = a;
    s.step = 0;
    q.push(s);

    while (!q.empty()){
        node u = q.front();
        q.pop();
        string temp;

        if(ma.count(u.str) == 1) //剪枝，判断重复的路径
            continue;

        if (u.str == b){
            ans = u.step;
            break;
        }
        ma[u.str] = 1;
        for (int i=0;i < u.str.length();i++)//枚举当前串所有可能位置
            for (int j=0; j<n; j++){//枚举所有可能手段
                temp = trans(u.str,i,j);
                if (temp != ""){
                    node v;
                    v.str = temp;
                    v.step = u.step+1;
                    q.push(v);
                }
            }
    }
    if (ans > 10 || ans == 0)
        cout << "NO ANSWER!" << endl;
    else
        cout << ans << endl;

}

int main(){
    cin >> a >> b;
    while (cin >> orginal[n] >> translated[n])
        n++;
    bfs();
    return 0;
}

```



# 并查集

并查集的思想在于用集合中的一个元素代表整个集合，可用一个father数组代表集合元素的父节点，当父节点是自身时即为代表元素

初始化：

```C++
void init(int n)
{
  for(int i=1;i<=n;i++)
    fa[i]=i;
}
```

查询：

```C++
int find(int x)
{
  if(x==fa[x])
    return x;
  else
    return fa[x];
}
```

合并：

```C++
void merge(int i,int j)
{
  fa[find(i)]=find(j);
}
```

路经压缩:

在查询的过程中，把沿途每个元素的父节点都设为根节点即可

```C++
int find(int x)
{
  return x==fa[x]?x:(fa[x]=find(fa[x]));
}
```

进一步优化：按秩合并：

```C++
void init(int n)
{
  for(int i=1;i<=n;i++)
  {
    fa[i]=i;
    rank[i]=1;
  }
}
int find(int x)
{
  return x==fa[x]?(fa[x]=find(fa[x]));
}
void merge(int i,int j)
{
  int x=find(i),y=find(j);
  if(rank[x]<=rank[y])
    fa[x]=y;
  else
    fa[y]=x;
  if(rank[x]==rank[y]&&x!=y)
    rank[y]++;
}
```

## 亲戚

题目背景:

若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。

题目描述:

规定：x 和 y 是亲戚，y 和 z 是亲戚，那么 x 和 z 也是亲戚。如果 x，y 是亲戚，那么 x 的亲戚都是 y 的亲戚，y 的亲戚也都是 x 的亲戚。 

```C++
#include<iostream>
using namespace std;
int n,m,p;
int fa[5005],rank1[5005];
void init(int n)
{
  for(int i=1;i<=n;i++)
  {
    fa[i]=i;
    rank1[i]=1;
  }
}
int find(int x)
{
  return x==fa[x]?x:(fa[x]=find(fa[x]));
}
void merge(int i,int j)
{
  int x=find(i),y=find(j);
  if(rank1[x]<=rank1[y])
    fa[x]=y;
  else
    fa[y]=x;
  if(rank1[x]==rank1[y]&&x!=y)
    rank1[y]++;
}
int main()
{
  cin>>n>>m>>p;
  init(n);
  for(int i=0;i<m;i++)
  {
    int a,b;
    cin>>a>>b;
    merge(a,b);
  }
  for(int i=0;i<p;i++)
  {
    int a,b;
    cin>>a>>b;
    if(find(a)==find(b))
      cout<<"Yes"<<endl;
    else
      cout<<"No"<<endl;
  }
  return 0;
}
```

## 奶酪

现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为 $z=0$，奶酪的上表面为 $z=h$。

现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry  可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry  则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。

位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑到奶酪的上表面去?

***Solution:*** 只需要判断是否有接地和接顶的空洞在同一个并查集即可

```C++
#include <cstdio>
#include <cstring>
#define MAXN 1005
typedef long long ll;
int fa[MAXN], rank[MAXN];
ll X[MAXN], Y[MAXN], Z[MAXN];
inline bool next_to(ll x1, ll y1, ll z1, ll x2, ll y2, ll z2, ll r)
{
    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2) <= 4 * r * r;
    //判断两个空洞是否相交或相切
}
inline void init(int n)
{
    for (int i = 1; i <= n; ++i)
    {
        fa[i] = i;
        rank[i] = 1;
    }
}
int find(int x)
{
    return x == fa[x] ? x : (fa[x] = find(fa[x]));
}
inline void merge(int i, int j)
{
    int x = find(i), y = find(j);
    if (rank[x] <= rank[y])
        fa[x] = y;
    else
        fa[y] = x;
    if (rank[x] == rank[y] && x != y)
        rank[y]++;
}
int main()
{
    int T, n, h;
    ll r;
    scanf("%d", &T);
    for (int I = 0; I < T; ++I)
    {
        memset(X, 0, sizeof(X));
        memset(Y, 0, sizeof(Y));
        memset(Z, 0, sizeof(Z));
        scanf("%d%d%lld", &n, &h, &r);
        init(n);
        fa[1001] = 1001; //用1001代表底部
        fa[1002] = 1002; //用1002代表顶部
        for (int i = 1; i <= n; ++i)
            scanf("%lld%lld%lld", X + i, Y + i, Z + i);
        for (int i = 1; i <= n; ++i)
        {
            if (Z[i] <= r)
                merge(i, 1001); //与底部接触的空洞与底部合并
            if (Z[i] + r >= h)
                merge(i, 1002); //与顶部接触的空洞与顶部合并
        }
        for (int i = 1; i <= n; ++i)
        {
            for (int j = i + 1; j <= n; ++j)
            {
                if (next_to(X[i], Y[i], Z[i], X[j], Y[j], Z[j], r))
                    merge(i, j); //遍历所有空洞，合并相交或相切的球
            }
        }
        printf("%s\n", find(1001) == find(1002) ? "Yes" : "No");
    }
    return 0;
}

```



# 树

## 字典树

```C++
struct Trie
{
    int count,prefix;
    Trie *Nextnode[26];
};
Trie* create_node()
{
    Trie *p=new Trie;
    for(int i=0;i<26;i++)
    {
        p->Nextnode[i]=NULL;
    }
    p->count=p->prefix=0;
    return p;
}
void insert(Trie *root,string s)
{
    if(s.length()==0)
    return;
    for(int i=0;i<s.length();i++)
    {
        if(root->Nextnode[s[i]-'a']==NULL)
        {
            root->Nextnode[s[i]-'a']=create_node();
        }
        root=root->Nextnode[s[i]-'a'];
        root->prefix++;
    }
    root->count++;
}
int search(Trie *root,string s)
{
  if(s.length()==0) return -1;
  for(int i=0;i<s.length();i++)
  {
      if(root->Nextnode[s[i]-'a']==NULL) return -1;
      root=root->Nextnode[s[i]-'a'];
  }
  return root->count;
}
int search_prefix(Trie *root,string s)
{
      if(s.length()==0) return -1;
      for(int i=0;i<s.length();i++)
      {
        if(root->Nextnode[s[i]-'a']==NULL) return -1;
        root=root->Nextnode[s[i]-'a'];
      }
      return root->prefix;
}
```

## 二叉树中序遍历

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

***Solution：***

法一：dfs+递归

```C++
class Solution {
public:
  vector<int> num;
  void dfs(TreeNode *root)
  {
    if(root==NULL) return;
    bfs(root->left);
    num.push_back(root->val);
    bfs(root->right);
  }
  vector<int> inorderTraversal(TreeNode* root) {
    dfs(root);
    return num;
  }
};
```

法二：迭代(入栈出栈)

```c++
class Solution{
public:
  vector<int> nums;
  vector<int> inorderTraversal(TreeNode *root){
    if(root==nullptr) return;
    stack<TreeNode*> s;
    s.push(root);
    while(root->left!=NULL)
    {
      s.push(root->left);
      root=root->left;
    }
    while(s.size())
    {
      root=s.top();
      s.pop();
      num.push_back(root->val);
      if(root->right!=NULL)
      {
        root=root->right;
        s.push(root);
        while(root->left!=NULL)
        {
          s.push(root->left);
          root=root->left;
        }
      }
    }
    return nums;
  }
};
```

## 二叉树的层序遍历

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。（即逐层地，从左到右访问所有节点）。

***Solution：*** 队列+BFS

- 首先根元素入队
- 当队列不为空的时候
  - 求当前队列的长度$s_i$
  - 依次从队列中取$s_i$ 个元素进行拓展，然后进入下一次迭代

```C++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
      vector<vector<int>> ret;
      if(!root) return ret;
      queue<TreeNode*> q;
      q.push(root);
      while(!q.empty())
      {
        vector<int> temp;
        int cur_size=q.size();
        for(int i=0;i<cur_size;i++)
        {
          auto node=q.front();
          q.pop();
          temp.push_back(node->val);
          if(node->left) q.push(node->left);
          if(node->right) q.push(node->right);
        }
        ret.push_back(temp);
      }
      return ret;
    }
};
```

## 二叉树的锯齿形层序遍历

给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

***Solution：***BFS

为了满足题目要求的**返回值**为「先从左往右，再从右往左」交替输出的锯齿形，我们可以利用双端队列来维护当前层节点值输出的顺序。

在广度优先搜索遍历当前层节点拓展下一层节点的时候我们仍然从左往右按顺序拓展，但是对当前层节点的存储我们维护一个变量 

$isOrderLeft$记录是从左至右还是从右至左的：

如果从左至右，我们每次将被遍历到的元素插入至双端队列的末尾。

如果从右至左，我们每次将被遍历到的元素插入至双端队列的头部。

```C++
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
      vector<vector<int>> ret;
      if(!root) return ret;
      queue<TreeNode*> q;
      q.push(root);
      bool isOrderLeft=true;
      while(!q.empty())
      {
        deque<int> d;
        int cur_size=q.size();
        for(int i=0;i<cur_size;i++)
        {
          auto node=q.front();
          q.pop();
          if(isOrderLeft)
            d.push_back(node->val);
          else 
            d.push_front(node->val);
          if(node->left) q.push(node->left);
          if(node->right) q.push(node->right);
        }
        ret.emplace_back(vector<int>{d.begin(),d.end()});
        isOrderLeft=!isOrderLeft;
      }
      return ret;
    }
};
```

## 从前序与中序遍历序列构造二叉树

给定一棵树的前序遍历 `preorder` 与中序遍历 `inorder`。请构造二叉树并返回其根节点。(`preorder` 和 `inorder` 均无重复元素)



# 数组

## 不修改数组找出重复的数字（分治算法）

给定一个长度为 *n*+1 的数组`nums`，数组中所有的数均在 1∼*n* 的范围内，其中 *n*≥1。请找出数组中任意一个重复的数，但不能修改输入的数组。

***Solution:***

[抽屉原理]: ：n+1个苹果放在n个抽屉里，那么至少有一个抽屉中会放两个苹果。

然后我们采用分治的思想，将每个数的取值的区间[1, n]划分成[1, n/2]和[n/2+1, n]两个子区间，然后分别统计两个区间中数的个数。
注意这里的区间是指数的取值范围，而不是 数组下标。划分之后，左右两个区间里一定至少存在一个区间，区间中数的个数大于区间长度。因此我们可以把问题划归到左右两个子区间中的一个，而且由于区间中数的个数大于区间长度，根据抽屉原理，在这个子区间中一定存在某个数出现了两次。依次类推，每次我们可以把区间长度缩小一半，直到区间长度为1时，我们就找到了答案。

（$\mathbb{O}(nlogn)$):

```C++
class Solution{
  public:
	int duplicateInArray(vector<int> &nums){
    if(nums.size()==0) return -1;
    int l=1,r=nums.size()-1;
    while(l<r)
    {
      int mid=(r-l)/2+l;
      int cnt=0;
      for(auto x:nums)
      {
        if(x>=l&&x<=mid) cnt++;
      }
      if(cnt>mid-l+1) r=mid;
      else l=mid+1;
    }
    return l;
  }
};
```

## 二维数组的查找（单调性查找）

在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

***Solution:***

核心在于发现每个子矩阵右上角的数的性质：x左边的数都小于等于x，x下边的数都大于等于x。

因此我们可以从整个矩阵的右上角开始枚举，假设当前枚举的数是 x

**·**	如果x等于target，则说明我们找到了目标值，返回true；
**·**	如果 x小于target，则 x左边的数一定都小于target，我们可以直接排除当前一整行的数；
**·**	如果 x大于target，则 x 下边的数一定都大于target，我们可以直接排除当前一整列的数；

**时间复杂度分析：**

每一步会排除一行或者一列，矩阵一共有 n行，m 列，所以最多会进行 n+m 步。所以时间复杂度是$\mathbb{O} (n+m)$。

```C++
class Solution{
  public:
  bool searchArray(vector<vector<int>> array, int target){
    if(array.empty()||array[0].empty()) return false;
    int i=0,j=array[0].size()-1;
    while(i<=array.size-1&&j>=0)
    {
      if(target==array[i][j]) return true;
      else if(targrt>array[i][j]) i++;
      else j--;
    }
    return false;
  }
};
```

## 有序数组的平方

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

***Solution：***

法一：直接排序：$O(nlog⁡n)$

```C++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        vector<int> ans;
        for (int num: nums) {
            ans.push_back(num * num);
        }
        sort(ans.begin(), ans.end());
        return ans;
    }
};
```

法二：双指针+归并：$O(n)$

```C++
class Solution{
public:
  vector<int> sortedSquares(vector<int> &nums){
    vector<int> ans;
    int negative=0;
    for(int i=0;i<nums.size()-1;i++)
    {
      if(nums[i]<0)
        negative=i;
      else break;
    }
    int i=negative,j=negative+1;
    while(i>=0||j<nums.size())
    {
      if(i<0)
      {
        ans.push_back(nums[j]*nums[j]);
        j++;
      }
      if(j==nums.size())
      {
        ans.push_back(nums[i]*nums[i]);
        i--;
      }
      if(nums[j]*nums[j]>nums[i]*nums[i])
      {
        ans.push_back(nums[j]*nums[j]);
        j++;
      }
      else 
      {
        ans.push_back(nums[i]*nums[i]);
        i--;
      }
    }
    return ans;
  }
};
```

方法三：双指针：$O(n)$

```C++
class Solution{
public:
  vector<int> sortedSquares(vector<int> &nums){
    vector<int> ans(nums.size());
    for(int i=0,j=nums.size()-1,pos=nums.size()-1;i<=j;pos--)
    {
      if(nums[i]*nums[i]>nums[j]*nums[j])
      {
        ans[pos]=nums[i]*nums[i];
        i++;
      }
      else
      {
        ans[pos]=nums[j]*nums[j];
        j--;
      }
    }
    return ans;
  }
};
```

## 旋转数组

给定一个数组，将数组中的元素向右移动 `k` 个位置，其中 `k` 是非负数。

***Solution：***

法一：使用额外的数组，空间复杂度：$O(n)$

```C++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> newArr(n);
        for (int i = 0; i < n; ++i) {
            newArr[(i + k) % n] = nums[i];
        }
        nums.assign(newArr.begin(), newArr.end());
    }
};
```

法二：环状替换，空间复杂度：$O(1)$

我们可以将被替换的元素保存在变量$temp$中，从而避免了额外数组的开销。我们从位置0开始，最初令 $temp=nums[0]$。根据规则，位置0的元素会放至$(0+k)\mod n$的位置，令$ x=(0+k) \mod n$，此时交换$temp$和 $nums[x]$，完成位置$x$的更新。然后，我们考察位置$x$，并交换$temp$和$nums[(x+k) \mod n]$，从而完成下一个位置的更新。不断进行上述过程，直至回到初始位置0。

容易发现，当回到初始位置0时，有些数字可能还没有遍历到，此时我们应该从下一个数字开始重复的过程，可是这个时候怎么才算遍历结束呢？我们不妨先考虑这样一个问题：从0开始不断遍历，最终回到起点0的过程中，我们遍历了多少个元素？

由于最终回到了起点，故该过程恰好走了整数数量的圈，不妨设为$a$圈；再设该过程总共遍历了$b$个元素。因此，我们有$an=bk$，即$an$ 一定为$n,k$的公倍数。又因为我们在第一次回到起点时就结束，因此$a$要尽可能小，故$an$就是$n,k$的最小公倍数$lcm(n,k)$，因此$b$就为 $\frac{lcm(n,k)}{k}$。这说明单次遍历会访问到$\frac{lcm(n,k)}{k}$ 个元素。为了访问到所有的元素，我们需要进行遍历的次数为：
$$
\frac{n}{lcm(n,k)/k}=\frac{nk}{lcm(n,k)}=gcd(n,k)
$$

```C++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
      int n=nums.size();
      k%=n;
      int count=gcd(k,n);
      for(int start=0;start<count;start++)
      {
        int cur=start;
        int pre=nums[start];
        do{
            int next=(cur+k)%n;
            swap(pre,nums[next]);
            cur=next;
        }while(start!=cur)
      }
   }
};
```

法三：数组翻转：空间复杂度：$O(1)$

该方法基于如下的事实：当我们将数组的元素向右移动$k$次后，尾部$k \mod n$个元素会移动至数组头部，其余元素向后移动$k \mod n$个位置。

该方法为数组的翻转：我们可以先将所有元素翻转，这样尾部的$k \mod n$个元素就被移至数组头部，然后我们再翻转$[0, k\bmod n-1]$区间的元素和$[k \mod n,n-1]$区间的元素即能得到最后的答案

```C++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
      k%=nums.size();
      reverse(nums.begin(),nums.end());
      reverse(nums.begin(),nums.begin()+k%nums.size());
      reverse(nums.begin()+k%nums.size(),nums.end());
  }
};
```

## 移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

***Solution：***

法一：

```C++
class Solution{
public:
  void moveZeroes(vector<int>& nums) {
    int index=0;
    for(int num:nums)
    {
      if(num)
        nums[index++]=num;
    }
    for(int i=index;i<nums.size();i++)
    {
      nums[i]=0;
    }
  }
};
```

法二：双指针：

使用双指针，左指针指向**当前已经处理好的序列**的尾部，右指针指向待处理序列的头部。右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。

注意到以下性质：左指针左边均为非零数；右指针左边直到左指针处均为零。

因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。

```C++
class Solution{
public:
  void moveZeroes(vector<int>& nums) {
    int left=0,right=0;
    while(right<nums.size())
    {
      if(nums[right])
      {
        swap(nums[right],nums[left]);
        left++:
      } 
      right++;
    }
  }
};
```

## 珠心算测验

珠心算是一种通过在脑中模拟算盘变化来完成快速运算的一种计算技术。珠心算训练，既能够开发智力，又能够为日常生活带来很多便利，因而在很多学校得到普及。某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？

最近老师出了一些测验题，请你帮忙求出答案。

***Solution：***

```C++
#include<iostream>
using namespace std;
int t[20005],g[20005];
int main()
{
  int ans=0,n;
  cin>>n;
  int maxn=0,a[105];
  for(int i=1;i<=n;i++)
  {
    cin>>a[i];
    g[a[i]]=1;
  }
  for(int i=1;i<n;i++)
  {
    for(int j=i+1;j<=n;j++)
    {
      t[a[i]+a[j]]++;
      maxn=max(maxn,a[i]+a[j]);
    }
  }
  for(int i=1;i<=maxn;i++)
  {
    if(g[i]&&t[i]>0) ans++;
  }
  cout<<ans<<endl;
  return 0;
}
```

## 排序模版

### 快排

分治思想

```C++
#include<iostream>
using namespace std;
int arr[100005];
void quicksort(int l,int r)
{
  int mid=a[(r-l)/2+l];
  int i=l,j=r;
  do{
      while(arr[i]<=mid) i++;
      while(arr[j]>=mid) j--;
      if(i<=j)
      {
        swap(arr[i],arr[j]);
        i++;
        j--;
      }
  }while(i<=j);
  if(l<j) quicksort(l,j);
  if(r>i) quicksort(i,r);
}
```

或者：

```C++
void quicksort(int l,int r)
{
  if(l>=r) return;
  int i=l,j=r;
  int key=arr[l];
  while(i<j)
  {
    while(i<j&&arr[j]>key) j--;
    if(i<j) arr[i]=arr[j];
    while(i<j&&arr[i]<=key) i++;
    if(i<j) arr[j]=arr[i];
  }
  arr[i]=key;
  quicksort(l,i-1);
  quicksort(j+1,r);
}
```

解释：

```C++
e.g arr={2,1,3,5,4}
step 1: l=0,r=4;
        i=0,j=4,key=2;
        substep1: j-- until j=1, arr[0]=arr[1]=1;
        substep2: i++ until i=j=1;
        arr[1]=2;
        arr[] changed into {1,2,3,5,4};
        quicksort(0,0) //return;
        quicksort(2,4)
          step 2:i=l=2,j=r=4,key=3;
                substep1: j-- until j=2;...
                quicksort(3,4) which is swap(5,4) end
```

### 归并排序

对于两个已排好序的数组，归并排序会非常快

#### 瑞士轮

$2×N$ 名编号为 $1∼2N$ 的选手共进行 $R$ 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。

每轮比赛的对阵安排与该轮比赛开始前的排名有关：第1名和第2名、第3名和第4名、……、第 $2K−1$ 名和第 $2K$ 名、……  、第 $2N−1$ 名和第 $2N$ 名，各进行一场比赛。每场比赛胜者得1分，负者得0分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。

现给定每个选手的初始分数及其实力值，试计算在 $R$ 轮比赛过后，排名第 $Q$ 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。

**Solution：**

关于sort的浪费：每次需要更新的值，都是相邻两个人变化后的分数；而相邻的分数，有些是不会改变位置的，而快速排序则是每次全部修改，必然会造成浪费。

所以我们可以考虑维护两个数组，win[]、lose[]，分别记录一轮比赛的胜者和败者，则两个数组是自动排好序的，只需要把这两个数组归并即可。

```C++
#include<iostream>
#include<algorithm>
using namespace std;
struct player
{
  int num,score,strength;
};
const int MAX=200100;
player win[MAX],lose[MAX],arr[MAX];
bool cmp(player &p1,player &p2)
{
  if(p1.score==p2.score)
    return p1.num<p2.num;
  else
    return p1.score>p2.score;
}
void merge()
{
  int i=1,j=1;
  int key=0;
  while(i<=win[0]&&j<=lose[0])
  {
    if(cmp(win[i],lose[j]))
      arr[++key]=win[i++];
    else
      arr[++key]=lose[j++];
  }
  while(i<=win[0]) arr[++key]=win[i++];
  while(j<=lose[0]) arr[++key]=lose[i++];
}
int main()
{
  int N,R,Q;
  cin>>N>>R>>Q;
  for(int i=1;i<=2*N;i++)
  {
    cin>>arr[i].score;
    arr[i].num=i;
  }
  for(int i=1;i<=2*N;i++)
  {
    cin>>arr[i].strength;
  }
  sort(arr+1,arr+2*N+1,cmp);
  for(int i=0;i<R;i++)
  {
    win[0]=0,lose[0]=0;
    for(int j=1;j<=2*N;j+=2)
    {
      if(arr[j].strength>arr[j+1].strength)
      {
        arr[j].score++;
        win[++win[0]]=arr[j];
        lose[++lose[0]]=arr[j+1];
      }
      else
      {
        arr[j+1].score++;
        win[++win[0]]=arr[j+1];
        lose[++lose[0]]=arr[j];
      }
    }
    merge();
  }
  cout<<arr[Q].num<<endl;
  return 0;
}
```

#### 逆序对

给一个数组，计算逆序对数

**Solution：** 如果数组是排好序分成两半的，那么在归并过程中若发现前面下标是 $i$ 的数大于第二部分数组的数 $j$ ，那么第一部分数组后面的数与 $j$ 都会构成逆序对

```C++
#include<iostream>
using namespace std;
int n, a[5000001], b[5000001];
long long cnt;
void mergesort(int l,int r)
{
  int mid=(r-l)/2+l;
  if(l==r) return;
  else
  {
    mergesort(l,mid);
    mergesort(mid+1,r);
  }
  int i=l,j=mid+1;
  int t=l;
  while(i<=mid&&j<=r)
  {
    if(a[i]>a[j])
    {
      cnt+=(mid-i+1);
      b[t++]=a[j++];
    }
    else
    {
      b[t++]=a[i++];
    }
  }
  while(i<=mid) b[t++]=a[i++];
  while(j<=r) b[t++]=a[j++];
  for(int w=l;w<=r;w++)
  {
    a[w]=b[w];
  }
}
int main()
{
  cin>>n;
  for(int i=1;i<=n;i++)
  {
    cin>>a[i];
  }
  mergesort(1,n);
  cout<<cnt<<endl;
  return 0;
}
```
## 树状数组
实现单点求和和区间修改，$O(\log n)$
```C++
#define lowbit(x) ((x)&(-x))
int tree[maxn];
inline void update(int i,int x){
  for(int pos=i;pos<=maxn;pos+=lowbit(pos)){
    tree[pos]+=x;
  }
}
inline int query1(int n){
  int ans=0;
  for(int pos=n;pos;pos-=lowbit(pos)){
    ans+=tree[pos];
  }
  return ans;
}
inline int query2(int a,int b){
  return query1(b)-query1(a);
}
```
## Sparse Table
解决 RMQ(Range Maximum/Minimum Query) 问题
用 $f[a][b]$ 维护 $[a,a+2^b-1]$ 的区间最大值
```C++
int f[maxn][21],Log2[maxn];
void init(){
  for(int i=1;i<=n;i++){
    f[i][0]=read();
  }
  for(int i=1;i<=20;i++){
    for(int j=1;j+(1<<i)-1<=n;j++){
      f[j][i]=max(f[j][i-1],f[j+(1<<(i-1))][i-1]);
    }
  }
  for(int i=2;i<=n;i++){
    Log2[i]=Log2[i/2]+1;
  }
}
void query(int l,int r){
  int s=Log2[r-l+1];
  return max(f[l][s],f[r-(1<<s)+1][s]);
}
```

# 堆

## 小根堆

大根堆同理

```C++
#include<iostream>
#include<cstring>
using namespace std;

template<typename item>
class smallest_heap{
    private:
        item heap[10001];
        int len;
    public:
        smallest_heap();
        void push(item const &);
        void pop();
        item top();
        int size();
        bool empty();
        
};

template<typename item>
smallest_heap<item>::smallest_heap(){
    len=0;
    memset(heap,0,sizeof(heap));
}

template<typename item>
void smallest_heap<item>::push(item const &n){
    heap[++len]=n;
    int son=len,father=son/2;
    while(heap[son]<heap[father] && father>=1){
        swap(heap[son],heap[father]);
        son=father,father=son/2;
    }
}

template<typename item>
void smallest_heap<item>::pop(){
    swap(heap[1],heap[len]);
    heap[len--]=0;
    int father=1,son=2;
    while(son<=len){
        if(son<len && heap[son]>heap[son+1]) son++;
        if(heap[father]>heap[son]){
            swap(heap[father],heap[son]);
            father=son,son=father*2;
        }else break;
    }
}

template<typename item>
item smallest_heap<item>::top(){
    return heap[1];
}

template<typename item>
int smallest_heap<item>::size(){
    return len;
}

template<typename item>
bool smallest_heap<item>::empty(){
    return len;
}

smallest_heap<int> h;

```



# 字符串

## 字母异位词分组

给你一个字符串数组，请你将**字母异位词**组合在一起。可以按任意顺序返回结果列表。

**字母异位词**是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母都恰好只用一次。

***Solution：*** Hash Map

```C++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        map<string,vector<string>> mapping;
        vector<vector<string>> ret;
        for(auto n:strs){
            string temp=n;
            sort(temp.begin(),temp.end());
            mapping[temp].push_back(n);
        }
        for(auto n:mapping)
            ret.push_back(n.second);
        return ret;
    }
};
```

## 无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

***Solution：***

法一：动态规划

设$dp[i]$为以$i$结尾的字符串的最大长度，则如果出现重复，从重复的地方重新计算长度

```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.length()<2) return s.length();
        int dp[s.length()];
        dp[0]=1;
        int max=1;
        for(int i=1;i<s.length();i++)
        {
            dp[i]=dp[i-1]+1;
            int index=i-dp[i-1];
            while(index<i)
            {
                if(s[i]==s[index])
                {
                    dp[i]=i-index;
                    break;
                }
                index++;
            }
            max=max>dp[i]?max:dp[i];
        }
        return max;
    }
};
```

法二：维护一个队列，其中所有元素都是无重复

先放代码：

```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        bool seen[255] = {false};
        int max = 1, j = 0;//j代表队列头
        for (int i = 0; i < s.size(); ++i) {
            while (seen[s[i]]) {
                seen[s[j]] = false;
                ++j;
            }
            seen[s[i]] = true;
            max = max(max, i-j+1);
        }
        return c;
    }
};
```

以“pwawkew”为例:

```C++
i=0: seen[p]=true; j=0; max=1
i=1: seen[w]=true; j=0; max=2
i=2: seen[a]=true; j=0; max=3
i=3: 因为seen[w]=true，进入while循环:
     loop 1: seen[p]=false; j=1//相当于p出队列
     loop 2: seen[w]=false; j=2//break;
     seen[w]=true; j=2;max=3;
i=4: seen[k]=true; j=2; max=3;
i=5: seen[e]=true; j=2; max=4;
i=6: seen[w]=true,进入while循环
     loop 1:seen[a]=false; j=3
     loop 2:seen[w]=false; j=4//break;
     seen[w]=true; j=4; max=4;//结束
```

## 最长回文子串

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

***Solution：***双指针：

```C++
class Solution {
public:
    string longestPalindrome(string s) {
        if (s.size() <= 1)
            return s;
        int maxLenStart = 0, maxLen = 1;
        int mid = 0;
        while (mid < s.size()) {
            int midBegin = mid;
            int midEnd = mid;
            while (midEnd+1 < s.size() && s[midEnd] == s[midEnd+1]) midEnd++;
            mid = midEnd + 1;
            int left = midBegin, right = midEnd;
            while (left-1 >= 0 && right+1 < s.size() && s[left-1] == s[right+1]) {
                left--;
                right++;
            }
            int cur_len = right - left + 1;
            if (cur_len > maxLen) {
                maxLen = cur_len;
                maxLenStart = left;
            }
        }
        return s.substr(maxLenStart, maxLen);
    }
};
```

### Manacher

$\mathrm{O(n)}$ 复杂度，因为每个字符至多被访问两次

1.防止出现 ABBC 和 ABCBA 这样的两种情况，我们选择在每个相邻字符之间都插入\$
2.防止出现子串重复访问，设 `hw[i]`代表 i 扩展出回文子串的最大长度，用 `mx` 代表访问的边界字符，用 `mid` 代表 `mx` 对应回文子串的中间字符，那么如果 $i<mx$ ，则必定有 $hw[i]=min(mx-i,hw[2\cdot mid-i])$，如果 $i\geqslant mx$，$hw[i]=1$，然后再对 $i$ 进行扩展则可以避免重复访问一段回文串
```C++
#include<iostream>
#include<string>
#include<cstring>
using namespace std;
char s[32000005],st[32000005];
int p[32000005];
int change()
{
    int len=strlen(st);
    int j=2;
    s[0]='^';
    s[1]='$';
    for (int i=0;i<len;i++)
    {
        s[j++]=st[i];
        s[j++]='$';
    }
    s[j]='&';
    return j;
}
int Manacher()
{
    int len = change(), mid = 1, mx = 1, ans = -1;
    for (int i = 1; i < len;i++)
    {
        if(i<mx)
        {
            p[i] = min(mx - i, p[mid * 2 - i]);
        }
        else
            p[i] = 1;
        while(s[i-p[i]]==s[i+p[i]])
        {
            p[i]++;
        }
        if(mx<i+p[i])
        {
            mid = i;
            mx = i + p[i];
        }
        ans = max(ans, p[i] - 1);
    }
    return ans;
}
int main()
{
    scanf("%s", st);
    printf("%d\n", Manacher());
    return 0;
}
```

## 递增的三元子序列

给你一个整数数组$nums$，判断这个数组中是否存在长度为 3 的递增子序列。

如果存在这样的三元组下标$ (i, j, k)$ 且满足$i < j < k$，使得$nums[i] < nums[j] < nums[k]$，返回 true ；否则，返回 false 。

**Solution：** 贪心：

```c++
class Solution{
public:
  bool increasingTriplet(vector<int>& nums) {
    int min=pow(2,31)-1,sec_min=pow(2,31)-1;
    bool flag=false;
    for(int i=0;i<nums.size();i++)
    {
      if(nums[i]<=min) min=nums[i];
      else if(nums[i]<=sec_min) sec_min=nums[i];
      else{
        flag=true;
        break;
      }
    }
    return flag;
  }
};
```

这段代码看似是错误的，实则正确：

（为什么不用管先后顺序？ ）
eg: 2,1,5,0,4,6
1、x=2, min=2, sec_min=maxValue
2、x=1, min=1, sec_min=maxValue
3、x=5, min=1, sec_min= 5
4、x=0, min=0, sec_min= 5
5、x=4, min=0, sec_min= 4
6、x=6, min=0, sec_min= 4, x >sec_min结束；

此时返回的三个值是0 4 6，假设原序列中没有4，则返回值是 0 5 6，而真正的返回值是 1 5 6（1 4 6也可），也就是说，无论在哪个位置x>sec_min，都会存在一个min，在sec_min之前，有x>min，因为先有min，再有sec_min





# 链表

## 在$\mathbb{O(1)}$时间删除链表结点

**Solution:**

由于是单链表，我们不能找到前驱节点，所以我们不能按常规方法将该节点删除。我们可以换一种思路，将下一个节点的值复制到当前节点，然后将下一个节点删除即可。

```C++
class Solution {
public:
    void deleteNode(ListNode* node) {
      auto p = node->next;
      node->val = p->val;
      node->next = p->next;
      // 这两步的作用就是将 *(node->next) 赋值给 *node，所以可以合并成一条语句：
      // *node = *(node->next);
      delete p;
    }
};
```

## 删除链表中重复的节点 

在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留。

**Solution:** 线段扫描法：从前往后扫描整个链表，每次扫描元素相同的一段，如果这段中的元素个数多于1个，则将整段元素直接删除。

```C++
class Solution{
public:
  ListNode* deleteDuplication(ListNode* head) {
    auto pre=new ListNode(-1);
    pre->next=head;
    auto p=pre;
    while(p->next)
    {
      auto q=p->next;
      while(q&&q->val==p->next->val) q=q->next;
      if(q==p->next->next) p=p->next;//也就是上述循环条件只进行了一次就break了
      else p->next=q;//直接删除整段;
    }
    return pre->next;
  }
};
```

## 链表中环的入口结点

给定一个链表，若其中包含环，则输出环的入口节点。若其中不包含环，则输出`null`。

***Solution:*** 快慢指针法:

用两个指针 first,second 分别从起点开始走，first 每次走一步，second 每次走两步。如果过程中 second 走到null，则说明不存在环。否则当 first 和 second 相遇后，让 first 返回起点，second 待在原地不动，然后两个指针每次分别走一步，当相遇时，相遇点就是环的入口。

------

证明:

设first走了s步，二者在距离环入口x处相遇，入口结点距初始结点$l$，有：
$$
\quad \quad \quad \quad \quad \quad \quad x+l+kL=2s\quad //L是环的长度 \\
x+l=s \\
$$
作差得：$s=kL$,即s是环长的整数倍 

现让first返回起点，second不动，然后两个指针每次分别走一步，first走l步到环的入口，second走l步后有:
$$
x=(s-l+l) \mod L=0
$$
故二者在入口处相遇

------



```C++
class Solution{
public:
  ListNode *entryNodeOfLoop(ListNode *head){
    if(!head||!head->next) return 0;
    auto first=head,second=head;
    while(first&&second)
    {
      first=first->next;
      second=second->next;
      if(second) second=second->next;
      if(first==second)
      {
        first=head;
        while(first!=second)
        {
          first=first->next;
          second=second->next;
        }
        return first;
      }
    }
    return 0;
  }
};
```

## 反转链表

***Solution:*** 翻转即将所有节点的next指针指向前驱节点。由于是单链表，我们在迭代时不能直接找到前驱节点，所以我们需要一个额外的指针保存前驱节点。同时在改变当前节点的next指针前，不要忘记保存它的后继节点。

**迭代：**

```C++
class Solution{
public:
  ListNode* reverseList(ListNode* head) {
   	ListNode *pre=nullptr;
    ListNode *cur=head;
    while(cur)
    {
      ListNode *next=cur->next;
      cur->next=pre;
      pre=cur;
      cur=next;
    }
    return pre;
  }
};
```

**递归：**

```C++
class Solution{
public:
  ListNode* reverseList(ListNode* head) {
    if(!head||!head->next) return head;
    ListNode *tail=reverseList(head->next);
    head->next->next=head;
    head->next=nullptr;
    return tail;
  }
};
```

## 合并排序链表

输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。

***Solution：***

```C++
class Solution {
public:
    ListNode* merge(ListNode* l1, ListNode* l2) {
       ListNode *dummy=new ListNode(-1);
       ListNode *cur=dummy;
       while(l1&&l2)
       {
           if(l1->val<l2->val)
           {
               cur->next=l1;
               l1=l1->next;
           }
           else
           {
               cur->next=l2;
               l2=l2->next;
           }
           cur=cur->next;
       }
        cur->next=(l1==NULL?l2:l1);
       return dummy->next;
    }
};
```

## 复杂链表的复刻 

请实现一个函数可以复制一个复杂链表。在复杂链表中，每个结点除了有一个指针指向下一个结点外，还有一个额外的指针指向链表中的任意结点或者null。

(注意原链表不能改动)

***Solution：***

------

**暴力求解:**

双重for循环的主要目的是查找random节点的位置。时间复杂度是$\mathbb{O}(n^2)$。分为两步实现：

1. 根据next指针新建链表
2. 双重for循环，每次查找到一个random节点，就重新遍历查找其位置

```C++
class Solution {
public:
    ListNode *copyRandomList(ListNode *head) {
      ListNode* newlist=new ListNode(-1);
      ListNode* temp=newlist;
      //第一步，根据next指针新建链表
      for(auto node=head;node;node=node->next)
      {
        ListNode *new_node=new ListNode(node->val);
        temp->next=new_node;
        temp=temp->next;
      }
      // 第二步，双重for循环，每次查找到一个random节点，就重新遍历查找其位置
      for(auto curNode=newlist->next,node=head;curNode&&node;)
      {
        if(node->random)
        {
          auto r_curNode=newlist->next,r_node=head;
          while(r_node!=node->random&&r_node){
            r_curNode=r_curNode->next;
            r_node=r_node->next;
          }
          curNode->random=r_curNode;
        }
        curNode=curNode->next;
        node=node->next;
      }
      return newlist->next;
	}
};
```

------

**Hash map:**

因为hash表查找的时间复杂度是$\mathbb{O}$(1)，因此通过该方法可以把之前暴力求解中的$\mathbb{O}(n^2)$ 的复杂度用空间来代替。
分两步来实现：

1. 建立原链表和目标链表的对应关系，存储到hash表中
2. 遍历原链表，查看random节点，根据hash表中存储的对应关系，建立目标链表的random节点关系

```c++
class Solution {
public:
    ListNode *copyRandomList(ListNode *head) {
      unordered_map<LisNode*,ListNode*> hash;
      ListNode *newlist=new ListNode(-1);
      ListNode *temp=newlist;
      for(auto node=head;node;node=node->next)
      {
        ListNode *newNode=new ListNode(node->val);
        temp->next=newNode;
        hash.insert({node,temp});
        temp=temp->next;
      }
      for(auto node=head;node;node=node->next)
      {
        if(node->random) {
          auto curNode=hash[node];
          curNode->random=hash[node->random];
        }
      }
      return newlist->next;
  }
};
```

## 两个链表的第一个公共结点

输入两个链表，找出它们的第一个公共结点。当不存在公共节点时，返回空节点。

***Solution：***

如果有公共结点肯定是在后面重叠，且后面部分都是共同的。先计算出两个链表的长度，可以让比较长的先走两个链表长度之差的步数，两个再一起走。

```C++
class Solution {
public:
    ListNode *findFirstCommonNode(ListNode *headA, ListNode *headB) {
      auto p=headA,q=headB;
      int la=0,lb=0;
      for(auto node=headA;node;node=node->next) la++;
      for(auto node=headB;node;node=node->next) lb++;
      int k=la-lb;
      if(la<lb)
      {
        p=headB;
        q=headA;
        k=lb-la;
      }
      while(k--)
      {
        p=p->next;
      }
      while(p)
      {
        if(p==q) return p;
        p=p->next;
        q=q->next;
      }
      return nullptr;
   }
};
```

## 单链表

实现一个单链表，链表初始为空，支持三种操作：

1. 向链表头插入一个数；
2. 删除第k个插入的数后面的数；
3. 在第k个插入的数后插入一个数。

现在要对该链表进行M次操作，进行完所有操作后，从头到尾输出整个链表。

**注意**:题目中第*k*个插入的数并不是指当前链表的第*k*个数。例如操作过程中一共插入了 *n* 个数，则按照插入的时间顺序，这 *n* 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 *n* 个插入的数。

```C++
#include<iostream>
using namespace std;
const int N=100010;
int n,list[N],pointer[N],head,idx;
void init()
{
  head=-1;
  idx=0;
}
void insert_head(int x)
{
  list[idx]=x;
  pointer[idx]=head;
  head=idx;
  idx++;
}
void insert_k_aft(int k,int x)
{
  list[idx]=x;
  pointer[idx]=pointer[k];
  pointer[k]=idx;
  idx++;
}
void remove_k(int k)
{
  pointer[k]=pointer[pointer[k]];
}
int main()
{
  int M;
  cin>>M;
  init();
  for(int i=0;i<M;i++)
  {
    char o;
    cin>>o;
    if(o=='H')
    {
      int x;
      cin>>x;
      insert_head(x);
    }
    else if(o=='D')
    {
      int k;
      cin>>k;
      if(k==0)
      {
        head=pointer[head];
      }
      else
      {
        remove_k(k-1);
      }
    }
    else if(o=='I')
    {
      int k,x;
      cin>>k>>x;
      insert_k_aft(k-1,x);
    }
  }
  for(int i=head;i!=-1;i=pointer[i]) cout<<list[i]<<" ";
  cout<<endl;
  return 0;
}
```

## 双链表

实现一个双链表，双链表初始为空，支持 5种操作：

1. 在最左侧插入一个数；
2. 在最右侧插入一个数；
3. 将第 $k$ 个插入的数删除；
4. 在第 $k$ 个插入的数左侧插入一个数；
5. 在第 $k$ 个插入的数右侧插入一个数

***Solution：***

```C++
#include<iostream>
using namespace std;
const int N=1e5+10;
int l[N],r[N],index,value[N];
void ini()
{
    //一开始左边界节点指向右边界节点,右边界节点指向左边界节点
    r[0]=1;
    l[1]=0;
    //更新节点索引
    index=2;
}

void insert(int k,int x)//在第k个节点后插入x
{
    //将值赋给新节点
    value[index]=x;
    //将新节点分别指向插入位置的右节点和左节点
    r[index]=r[k];
    l[index]=k;
    //将新节点右边一节点向左指向新节点,将新节点左边一节点向右指向新节点
    l[r[k]]=index;
    r[k]=index;
    //更新节点索引
    index++;
}
void remove(int k)
{
    //删除第k个节点,第k-1的右指针指向原先第k个节点的右指针指向的节点
    r[l[k]]=r[k];
    //删除第k个节点,原先第k个节点的右指针指向的节点的左指针指向原先第k个节点的左指针指向
    //的节点
    l[r[k]]=l[k];
}
int main()
{
    // 0 是左边界  1是右边界
    //因为0和1都被占用,所以第1个节点也就是2=1+1 ,第2个节点为3=2+1;
    //∴第k个节点也就是k+1
    ini();
    int M,k,x;
    string operation;
    cin>>M;//操作个数
    while(M--)
    {
        cin>>operation;//操作指令
        if(operation=="L")//在链表的最左端插入x
        {
            //也就是在左边界后插入一个节点,就是最左端插入一个节点
            cin>>x;
            insert(0,x);
        }
        else if(operation=="R")//在链表的最右端插入x
        {
            //也就是右边界的左节点后插入一个新节点
            cin>>x;
            insert(l[1],x);
        }
        else if(operation=="D")//把第k个插入的数删除
        {
            cin>>k;
            remove(k+1);
        }
        else if(operation=="IL")//第k个插入的数左侧插入一个数
        {
            //也就是在第k个插入的数的左节点后插入一个数
            cin>>k>>x;
            insert(l[k+1],x);
        }
        else//第k个插入的数右侧插入一个数
        {
            //在第k个节点后插入一个数
            cin>>k>>x;
            insert(k+1,x);
        }
    }
    int pos=r[0];
    while(pos!=1)//当指向右边界节点时,循环结束
    {
        cout<<value[pos]<<" ";
        pos=r[pos];
    }
    return 0;
}
```

## 单链表快排

***Solution：*** 归并：

```C++
class Solution{
public:
ListNode *getTail(ListNode *head)
{
  while(head->next)
  {
    head=head->next;
  }
  return head;
}
ListNode* quickSortList(ListNode* head) {
  if(!head||!head->next) return head;
  auto lhead=new ListNode(-1),mhead=new ListNode(-1),rhead=new ListNode(-1);
  auto left=lhead,mid=mhead,right=rhead;
  int x=head->val;
  for(auto node=head;node;node=node->next)
  {
    if(node->val<x)
      left=left->next=node;
    else if(node->val==x)
      mid=mid->next=node;
    else 
      right=right->next=node;
  }
  left->next=right->next=mid->next=nullptr;
  lhead->next=quickSortList(lhead->next);
  rhead->next=quickSortList(rhead->next);
  getTail(lhead)->next=mhead->next;
  getTail(mhead)->next=rhead->next;
  auto ret=lhead->next;
  delete lhead;
  delete mhead;
  delete rhead;
  return ret;
  }
};
```

## 链表排序

***Solution：***

数组模拟链表

```C++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

const int N=1e5+10;

int e[N],ne[N],idx=0;
vector<pair<int,int>> res;

int main(){
    int n,head;
    cin>>n>>head;
    for(int i=0;i<n;i++){
        int addr,key,next;
        cin>>addr>>key>>next;
        e[addr]=key;
        ne[addr]=next;
    }
    for(int i=head;i!=-1;i=ne[i]) res.push_back({e[i],i});

    sort(res.begin(),res.end());
    if(res.size()==0) cout<<0<<" "<<-1<<endl;
    else{
        //cout<<res.size()<<" "<<res[0].second<<endl;
        printf("%d %05d\n",res.size(),res[0].second);
        for(int i=0;i<res.size();i++){
            if(i+1==res.size()) printf("%05d %d -1\n",res[i].second,res[i].first);
            else  printf("%05d %d %05d\n",res[i].second,res[i].first,res[i+1].second);
        }
    }
    return 0;
}
```

## 两数相加

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

***Solution：***

```C++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
      ListNode* ret=new ListNode;
      ListNode* temp=ret;
      int carry=0;
      while(carry>0||l1!=nullptr||l2!=nullptr)
      {
        if(l1!=nullptr)
        {
          carry+=l1->val;
          l1=l1->next;
        }
        if(l2!=nullptr)
        {
          carry+=l2->val;
          l2=l2->next;
        }
        temp->next=new ListNode(carry%10);
        temp=temp->next;
        carry/=10;
      }
      return ret->next;
    }
};
```

## 奇偶链表

给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

***Solution：***

```C++
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
    if(!head) return nullptr;
      ListNode *odd=head;
      ListNode *even=head->next;
      ListNode *evenHead=even;
      while(even&&even->next)
      {
        odd->next=even->next;
        odd=odd->next;
        even->next=odd->next;
        even=even->next;
      }
      odd->next=evenHead;
      return head;
    }
};
```

## 删除链表的倒数第N个结点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

***Solution：***

法一：计算链表长度：

```C++
class Solution {
public:
    int getLength(ListNode* head) {
        int length = 0;
        while (head) {
            ++length;
            head = head->next;
        }
        return length;
    }

    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode(0, head);
        int length = getLength(head);
        ListNode* cur = dummy;
        for (int i = 1; i < length - n + 1; ++i) {
            cur = cur->next;
        }
        cur->next = cur->next->next;
        ListNode* ans = dummy->next;
        delete dummy;
        return ans;
    }
};
```

法二： 栈

我们将各个结点依次入栈，然后开始出栈，直到倒数第n个结点出栈

```C++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
      ListNode* dummy=new ListNode(0,head);
      stack<ListNode*> stk;
      while(head!=NULL)
      {
        stk.push(head);
        head=head->next;
      }
      for(int i=0;i<n;i++)
      {
        stk.pop();
      }
      stk.top()->next=stk.top()->next->next;
      ListNode *ret=dummy->next;
      delete dummy;
      return ret;
    }
};
```

法三：快慢指针

先让快指针走n个结点，然后快慢指针同时走，直到快指针到空结点

```C++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode(0, head);
        ListNode* first = head;
        ListNode* second = dummy;
        for (int i = 0; i < n; ++i) {
            first = first->next;
        }
        while (first) {
            first = first->next;
            second = second->next;
        }
        second->next = second->next->next;
        ListNode* ans = dummy->next;
        delete dummy;
        return ans;
    }
};
```

# 高精度

## 加法

```C++
string add(string a,string b)
{
    string ret;
    int carry=0;
    reverse(a.begin(),a.end());
    reverse(b.begin(),b.end());
    for(int i=0;i<a.length()||i<b.length();i++)
    {
        if(i<a.length()) carry+=(a[i]-'0');
        if(i<b.length()) carry+=(b[i]-'0');
        ret+=(carry%10+'0');
        carry/=10;
    }
    while(carry>0)
    {
        ret+=(carry%10+'0');
      	carry/=10;
    }
    reverse(ret.begin(),ret.end());
    return ret;
}
```

## 高精乘低精

```C++
string high_low_multiply(string a,int b)
{
    string ret;
    int carry=0;
    reverse(a.begin(),a.end());
    for(int i=0;i<a.length();i++)
    {
        carry+=(a[i]-'0')*b;
        ret+=(carry%10+'0');
        carry/=10;
    }
    while(carry>0)
    {
        ret+=(carry%10+'0');
      	carry/=10;
    }
    reverse(ret.begin(),ret.end());
    return ret;
}
```

## 高精乘高精

```C++
#include<iostream>
#include<cstring>
using namespace std;
char a1[50001],b1[50001];
int a[50001],b[50001],i,x,len,j,c[50001];
int main ()
{
    cin >>a1 >>b1;
    a[0]=strlen(a1);b[0]=strlen(b1);
    for (i=1;i<=a[0];++i)a[i]=a1[a[0]-i]-'0';
    for (i=1;i<=b[0];++i)b[i]=b1[b[0]-i]-'0';
    for (i=1;i<=a[0];++i)for (j=1;j<=b[0];++j)c[i+j-1]+=a[i]*b[j];
    len=a[0]+b[0];                            
    for (i=1;i<len;++i)if (c[i]>9){c[i+1]+=c[i]/10;c[i]%=10;}
    while (c[len]==0&&len>1)len--;
    for (i=len;i>=1;--i)cout <<c[i];
    return 0;
}
```



# 数学

## 素数

### 埃氏筛

**如果$n$是素数，则$in，i=2,3,4,5...$不是素数**

e.g. 筛出100000以内的素数

```C++
#include<iostream>
using namespace std;
int main()
{
  bool prime[100001]={1};
  prime[1]=0;
  for(int i=2;i<=100001;i++)
  {
    if(prime[i])
    {
      for(int j=2*i;j<=100001;j+=i)
        prime[j]=0;
    }
  }
  return 0;
}
```



## 快速幂||取余运算模版

给你三个整数 $a,b,p$，求 $a^b \mod  p$。

***Solution ：***

### **快速幂**

我们考虑将 $b$ 拆分成二进制来减少运算次数，例如：
$$
a^{11}=a^8\times a^2 \times a^1
$$
而 $(11)_{2}=1011$，即二进制位的每一位非零数对应的2的幂次均是拆分后的乘数

给出快速幂代码：

```C++
int quickpower(a,b)
{
  int base=a,ans=1;
  while(b>0)
  {
    if(b&1)
    {
      ans*=base;
    }
    base*=base;
    b>>=1;
  }
  return ans;
}
```

解释：

### 位运算

(1) ``b&1``：按位与：

假如：``b=1010``，与0001作按位与：得到0000，可得b的最后一位是0，故此条判断语句是判断b的某一位是否为零

(2)``b>>=1``：右移运算，对无符号数高位补零，即把b的最后一位抛弃

| 符号 | 描述 | 运算规则                                                     |
| ---- | ---- | ------------------------------------------------------------ |
| &    | 与   | 两个位都为1时，结果才为1                                     |
| \|   | 或   | 两个位都为0时，结果才为0                                     |
| ^    | 异或 | 两个位相同为0，相异为1                                       |
| ~    | 取反 | 0变1，1变0                                                   |
| <<   | 左移 | 各二进位全部左移若干位，高位丢弃，低位补0                    |
| \>>  | 右移 | 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） |

**与运算的用途：**

1）清零

如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。

2）取一个数的指定位

比如取数 X=10101110的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=00001111，然后将X与Y进行按位与运算（X&Y=00001110）即可得到X的指定位。

3）判断奇偶

只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a & 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数

**或运算的用途：**

1）常用来对一个数据的某些位设置为1

比如将数 X=1010 1110 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X|Y=1010 1111）即可得到。

**异或运算的用途：**

1）翻转指定位

比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。

2）与0相异或值不变

例如：1010 1110 ^ 0000 0000 = 1010 1110

3）交换两个数

```C++
void swap(int a,int b)
{
  if(a!=b)
  {
    a^=b; //e.g a=1011 b=0101;a^=b:a=1110
    b^=a;//b^=a:b=1011
    a^=b;//a^=b:a=0101
  }
}
```

**取反运算的用途：**

1）使一个数的最低位为零

使a的最低位为0，可以表示为：a & ~1。~1的值为 1111 1111 1111 1110，再按"与"运算，最低位一定为0。因为" ~"运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。

### 取余

$$
(A+B)\mod b=A \mod b+B \mod b \\
(A \times B) \mod b=((A\mod b)\times (B \mod b))\mod b
$$

所以可以在快速幂中改成：

```C++
while(b > 0)
{
  if(b & 1)
  {
    ans *= base;
    ans %= m;
  }
  base *= base;
  base %= m;
  b>>=1;
}
```
**矩阵快速幂：** 重载`operator*()`，则和快速幂完全一样


